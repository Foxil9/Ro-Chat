This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.clineignore
.clinerules
.env.example
.gitattributes
.gitignore
electron-builder.json
memory_bank/activeContext.md
memory_bank/productContext.md
memory_bank/progress.md
memory_bank/projectbrief.md
memory_bank/systemPatterns.md
memory_bank/techContext.md
package.json
README.md
server/config/database.js
server/index.js
server/logging/logger.js
server/middleware/authMiddleware.js
server/models/Message.js
server/models/User.js
server/routes/auth.js
server/routes/chat.js
src/main/auth/robloxAuth.js
src/main/auth/tokenManager.js
src/main/detection/detector.js
src/main/detection/logMonitor.js
src/main/detection/memoryReader.js
src/main/detection/processWatcher
src/main/detection/processWatcher.js
src/main/index.js
src/main/ipc/handlers.js
src/main/logging/logger.js
src/main/logging/logRotate.js
src/main/storage/secureStore.js
src/preload/preload.js
src/renderer/css/main.css
src/renderer/css/themes.css
src/renderer/index.html
src/renderer/js/app.js
src/renderer/js/chat.js
src/renderer/js/settings.js
src/renderer/views/chat.html
src/renderer/views/login.html
src/renderer/views/settings.html
src/shared/constants.js
src/shared/utils.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".clineignore">
# Dependencies
node_modules/
*/node_modules

# Environment Variables - IGNORE actual secret files
.env
.env.local
.env.production
.env.development

# Environment Template - DO NOT IGNORE (Remove this line to track it)
# .env.example

# Build outputs
dist/
build/
*.tsbuildinfo
repomix-output.xml

# System & IDE files
.DS_Store
.vscode/
.chunkhound/
.idea/
.chunkhound.json
*.log
</file>

<file path=".clinerules">
# Cline's Memory Bank

I am Cline, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Memory Bank Structure

The Memory Bank consists of core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]

### Core Files (Required)
1. `projectbrief.md`
   - Foundation document that shapes all other files
   - Created at project start if it doesn't exist
   - Defines core requirements and goals
   - Source of truth for project scope

2. `productContext.md`
   - Why this project exists
   - Problems it solves
   - How it should work
   - User experience goals

3. `activeContext.md`
   - Current work focus
   - Recent changes
   - Next steps
   - Active decisions and considerations
   - Important patterns and preferences
   - Learnings and project insights

4. `systemPatterns.md`
   - System architecture
   - Key technical decisions
   - Design patterns in use
   - Component relationships
   - Critical implementation paths

5. `techContext.md`
   - Technologies used
   - Development setup
   - Technical constraints
   - Dependencies
   - Tool usage patterns

6. `progress.md`
   - What works
   - What's left to build
   - Current status
   - Known issues
   - Evolution of project decisions

### Additional Context
Create additional files/folders within memory-bank/ when they help organize:
- Complex feature documentation
- Integration specifications
- API documentation
- Testing strategies
- Deployment procedures

## Core Workflows

### Plan Mode
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}

    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]

    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]

### Act Mode
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Execute[Execute Task]
    Execute --> Document[Document Changes]

## Documentation Updates

Memory Bank updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory bank** (MUST review ALL files)
4. When context needs clarification

flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Document Insights & Patterns]

        P1 --> P2 --> P3 --> P4
    end

    Start --> Process

Note: When triggered by **update memory bank**, I MUST review every memory bank file, even if some don't require updates. Focus particularly on activeContext.md and progress.md as they track current state.

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.
</file>

<file path=".env.example">
# Database Configuration
DB_URL=mongodb://localhost:27017/rochat

# Server Configuration
SERVER_URL=http://localhost:3000
PORT=3000

# JWT Secret (generate a secure random string for production)
JWT_SECRET=your-secret-key-here

# Environment
NODE_ENV=development

# Roblox API
ROBLOX_API_KEY=your-roblox-api-key-here
</file>

<file path=".gitattributes">
*.exe filter=lfs diff=lfs merge=lfs -text
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build outputs
dist/
build/

# Environment variables
.env
.env.local
.env.production
.env.development

# Logs
logs/
*.log

# OS files
.DS_Store
Thumbs.db

# IDE files
.vscode/
.idea/
*.swp
*.swo

# Electron
out/

# Testing
coverage/

# Temporary files
*.tmp
.cache/
</file>

<file path="electron-builder.json">
{
  "appId": "com.rochat.app",
  "productName": "RoChat",
  "directories": {
    "output": "dist"
  },
  "files": [
    "src/**/*",
    "package.json"
  ],
  "win": {
    "target": [
      {
        "target": "nsis",
        "arch": [
          "x64"
        ]
      }
    ],
    "icon": "build/icon.ico"
  },
  "nsis": {
    "oneClick": false,
    "allowToChangeInstallationDirectory": true,
    "createDesktopShortcut": true,
    "createStartMenuShortcut": true
  },
  "mac": {
    "target": "dmg",
    "icon": "build/icon.icns"
  },
  "linux": {
    "target": "AppImage",
    "icon": "build/icon.png",
    "category": "Utility"
  }
}
</file>

<file path="memory_bank/activeContext.md">
# Active Context: RoChat

## Current Work Focus
**Status:** Project Structure Complete - January 20, 2026

The RoChat project has been fully structured with all directories and empty files created. The Memory Bank has been updated with comprehensive documentation about the project architecture, requirements, and technical context.

## Recent Changes

### January 20, 2026 - Project Structure Creation
- Created complete directory structure for RoChat application
- Created all source files (empty) for both Electron app and backend server
- Updated Memory Bank with comprehensive project documentation:
  - **projectbrief.md:** Project overview, requirements, goals, and success criteria
  - **productContext.md:** Product vision, problems solved, user experience goals
  - **systemPatterns.md:** Architecture diagram, design patterns, component relationships
  - **techContext.md:** Technology stack, development setup, build/deployment processes
  - **progress.md:** Updated with current project status and next steps

### Project Structure Created

**src/main/**
- `index.js` - Electron main process entry point
- `detection/` - Process detection module
  - `logMonitor.js` - Parse Roblox logs for chat
  - `memoryReader.js` - Memory scanning fallback
  - `processWatcher.js` - Monitor RobloxPlayerBeta.exe
  - `detector.js` - Combine both detection methods
- `auth/` - Authentication module
  - `robloxAuth.js` - OAuth/cookie login
  - `tokenManager.js` - Store/refresh tokens
- `storage/` - Secure storage
  - `secureStore.js` - Encrypted local storage
- `ipc/` - IPC communication
  - `handlers.js` - IPC handlers for main-renderer communication

**src/renderer/**
- `index.html` - Main entry point
- `js/` - Renderer logic
  - `app.js` - Main renderer logic
  - `chat.js` - Chat UI/logic
  - `settings.js` - Settings panel
- `css/` - Styling
  - `main.css` - Main stylesheet
  - `themes.css` - Theme variants
- `views/` - HTML views
  - `login.html` - Login view
  - `chat.html` - Chat view
  - `settings.html` - Settings view

**src/shared/**
- `constants.js` - PlaceID/JobID formats, paths
- `utils.js` - Helper functions

**server/**
- `index.js` - Backend server entry point
- `config/` - Configuration
  - `database.js` - DB connection setup
- `routes/` - API routes
  - `chat.js` - Chat relay endpoints
  - `auth.js` - Authentication endpoints
- `middleware/` - Express middleware
  - `authMiddleware.js` - Token verification
- `models/` - Data models
  - `User.js` - User model
  - `Message.js` - Message model

**Root Files**
- `.env.example` - Environment variable template
- `.env` - Environment variables (gitignored)
- `.gitignore` - Git ignore rules
- `package.json` - NPM dependencies and scripts
- `electron-builder.json` - Build configuration
- `README.md` - Project documentation

## Next Steps

### Immediate Priorities
1. **Initialize npm package** - Create `package.json` with dependencies and scripts
2. **Set up Electron main process** - Configure Electron app window and IPC handlers
3. **Implement process detection** - Build Roblox process watcher
4. **Create authentication flow** - Implement Roblox OAuth and cookie handling
5. **Set up database** - Configure MongoDB or PostgreSQL connection
6. **Build basic UI** - Create login, chat, and settings views

### Medium-Term Goals
- Implement log parsing for chat extraction
- Build memory scanner as fallback detection method
- Create secure storage implementation
- Set up Express backend server
- Implement chat relay API
- Add theme support

### Long-Term Goals
- Complete chat history persistence
- Add notification system
- Implement settings persistence
- Create comprehensive test suite
- Set up CI/CD pipeline
- Deploy production server

## Active Decisions and Considerations

### Decisions Made
- **Platform:** Electron for desktop application
- **Backend:** Node.js with Express.js
- **Detection:** Dual-method approach (logs + memory scanning)
- **Authentication:** OAuth and cookie-based login
- **Storage:** electron-store for encrypted local storage
- **Database:** MongoDB or PostgreSQL (decision pending)

### Pending Decisions
- Choose between MongoDB and PostgreSQL for database
- Decide whether to use a frontend framework (React/Vue) or vanilla JS
- Determine if TypeScript should be adopted
- Select testing framework for E2E testing
- Choose deployment platform for backend server

## Important Patterns and Preferences

### Code Organization
- Separation of concerns: Detection, Auth, Storage, IPC modules are independent
- Main process handles system-level operations
- Renderer process focuses on UI logic
- Backend server is separate from Electron app
- Shared constants and utilities across all processes

### Security Priorities
- All credentials encrypted at rest
- IPC communication validated and sanitized
- No sensitive data in renderer process
- JWT-based API authentication
- System keychain integration for secure storage

### Development Preferences
- Vanilla JavaScript initially (no framework overhead)
- Modular architecture for maintainability
- Comprehensive documentation in Memory Bank
- Clean code practices with ESLint and Prettier
- Git Flow branching strategy

## Learnings and Project Insights

### Project Insights
- Roblox chat detection requires dual-method approach for reliability
- Electron provides excellent IPC system for main-renderer communication
- Encrypted storage is critical for Roblox tokens/cookies
- Separate backend server enables future cross-platform expansion
- Database choice impacts data modeling approach

### Architecture Insights
- Detection module needs to be robust across Roblox versions
- Auth module must handle both OAuth and cookie flows
- Storage module should abstract encryption details
- IPC handlers provide clean API boundary
- Backend should be stateless for scalability

### Development Workflow Insights
- Memory Bank is essential for continuity across sessions
- Project structure established before implementation enables clear planning
- Separating Electron app and backend server allows independent scaling
- Comprehensive documentation reduces onboarding time

## Notes
As development progresses, this file should be updated to reflect:
- Current active work and focus areas
- Recent changes and implementations
- Immediate next steps
- Any important decisions or considerations
- Patterns discovered or established during development

## Questions for Next Session
- Which database should be used: MongoDB or PostgreSQL?
- Should we implement TypeScript from the start or migrate later?
- What is the priority order for implementing features?
- Should we add a frontend framework (React/Vue) or stick with vanilla JS?
- What testing framework should be used for E2E testing?
</file>

<file path="memory_bank/productContext.md">
# Product Context: RoChat

## Why This Project Exists
RoChat is a desktop application that allows Roblox players to view and manage in-game chat outside the Roblox client. It solves the problem of limited chat accessibility in Roblox by providing a dedicated, feature-rich chat interface.

## Problems It Solves
- **Limited Chat Visibility:** Roblox's in-game chat can be difficult to read and manage during gameplay
- **No Chat History:** Native Roblox doesn't persist chat logs
- **Multi-Session Management:** Players running multiple Roblox instances need better chat organization
- **Notification Management:** Players want better control over chat notifications

## How It Should Work
1. **Detection Phase:** Application detects when RobloxPlayerBeta.exe is running
2. **Authentication Phase:** User logs in via Roblox OAuth or provides cookies
3. **Monitoring Phase:** Application monitors Roblox logs and memory for chat activity
4. **Relay Phase:** Chat messages are extracted and relayed to the application
5. **Display Phase:** Messages are displayed in a dedicated UI with themes and settings
6. **Storage Phase:** Chat history and credentials are securely stored locally

## User Experience Goals
- **Seamless Integration:** Works alongside Roblox without interfering
- **Fast & Responsive:** Real-time chat updates with minimal latency
- **Secure:** Encrypted storage for all sensitive data
- **Customizable:** Themes, fonts, and notification preferences
- **Intuitive:** Simple setup process with clear feedback

## Target Users
- **Casual Players:** Want better chat visibility and history
- **Roleplayers:** Need persistent chat logs and better organization
- **Moderators/Admins:** Need to monitor multiple chat channels
- **Developers:** Want to test and debug game chat systems

## Key Features
- Roblox process detection (log monitoring + memory scanning fallback)
- Roblox OAuth/cookie authentication
- Secure token management with refresh capabilities
- Real-time chat relay from in-game
- Persistent chat history
- Theme support (light, dark, custom)
- Settings panel for customization
- Encrypted local storage using electron-store

## Differentiators
- **Dual Detection Methods:** Combines log parsing with memory scanning for reliability
- **Desktop-First:** Native Electron app for better performance and integration
- **Secure by Design:** End-to-end encryption for credentials
- **Roblox-Native:** Works directly with Roblox's existing systems
- **Flexible Authentication:** Supports both OAuth and cookie-based login

## Notes
The application operates as a companion to Roblox, reading chat data through approved detection methods without modifying the Roblox client.

## Future Considerations
- Should support group chats and direct messaging separately
- May add file sharing capabilities for in-game content
- Could integrate with Discord or other platforms
- Potential mobile companion app
- Cloud backup for chat history
</file>

<file path="memory_bank/progress.md">
# Progress: RoChat

## What Works

### Project Infrastructure
- ✅ Complete project directory structure created
- ✅ All source files created (empty, ready for implementation)
- ✅ Memory Bank fully documented with comprehensive project information
- ✅ Git repository initialized
- ✅ Git configuration established (.gitignore, .gitattributes)

### Documentation
- ✅ **projectbrief.md:** Complete project overview, requirements, goals, success criteria
- ✅ **productContext.md:** Product vision, problems solved, user experience goals, target users
- ✅ **systemPatterns.md:** Architecture diagram, design patterns, component relationships, critical paths
- ✅ **techContext.md:** Technology stack, development setup, build/deployment processes, testing strategy
- ✅ **activeContext.md:** Current work focus, recent changes, next steps, active decisions
- ✅ **progress.md:** This file - tracking project progress

### File Structure (21 Files Created)

**Electron Main Process (5 files)**
- src/main/index.js
- src/main/detection/logMonitor.js
- src/main/detection/memoryReader.js
- src/main/detection/processWatcher.js
- src/main/detection/detector.js
- src/main/auth/robloxAuth.js
- src/main/auth/tokenManager.js
- src/main/storage/secureStore.js
- src/main/ipc/handlers.js

**Electron Renderer Process (9 files)**
- src/renderer/index.html
- src/renderer/js/app.js
- src/renderer/js/chat.js
- src/renderer/js/settings.js
- src/renderer/css/main.css
- src/renderer/css/themes.css
- src/renderer/views/login.html
- src/renderer/views/chat.html
- src/renderer/views/settings.html

**Shared Code (2 files)**
- src/shared/constants.js
- src/shared/utils.js

**Backend Server (7 files)**
- server/index.js
- server/config/database.js
- server/routes/chat.js
- server/routes/auth.js
- server/middleware/authMiddleware.js
- server/models/User.js
- server/models/Message.js

**Root Files (5 files)**
- .env.example
- .env (gitignored)
- .gitignore
- package.json
- electron-builder.json
- README.md

## What's Left to Build

### Phase 1: Foundation Setup
- [ ] Create package.json with all dependencies and scripts
- [ ] Set up ESLint and Prettier configuration
- [ ] Create basic README with setup instructions
- [ ] Initialize npm project and install dependencies

### Phase 2: Electron Main Process
- [ ] Configure Electron app and create main window
- [ ] Implement IPC handlers (handlers.js)
- [ ] Create secure store implementation (secureStore.js)
- [ ] Set up Roblox OAuth authentication (robloxAuth.js)
- [ ] Implement token manager (tokenManager.js)

### Phase 3: Detection Module
- [ ] Build process watcher (processWatcher.js)
- [ ] Implement log monitor for chat parsing (logMonitor.js)
- [ ] Create memory reader as fallback (memoryReader.js)
- [ ] Combine both methods in detector.js

### Phase 4: Backend Server
- [ ] Set up Express server (server/index.js)
- [ ] Configure database connection (database.js)
- [ ] Create User model (models/User.js)
- [ ] Create Message model (models/Message.js)
- [ ] Implement authentication routes (routes/auth.js)
- [ ] Implement chat relay routes (routes/chat.js)
- [ ] Create authentication middleware (middleware/authMiddleware.js)

### Phase 5: Renderer UI
- [ ] Build login view (views/login.html + js logic)
- [ ] Build chat view (views/chat.html + chat.js)
- [ ] Build settings view (views/settings.html + settings.js)
- [ ] Create main CSS styling (css/main.css)
- [ ] Implement theme system (css/themes.css)
- [ ] Create app entry logic (js/app.js)

### Phase 6: Integration & Testing
- [ ] Connect renderer to main process via IPC
- [ ] Connect main process to backend server
- [ ] End-to-end testing of chat relay flow
- [ ] Test authentication flow (OAuth and cookies)
- [ ] Test detection methods (logs and memory)
- [ ] Test secure storage

### Phase 7: Polish & Features
- [ ] Add notification system
- [ ] Implement settings persistence
- [ ] Add error handling and user feedback
- [ ] Create loading states and animations
- [ ] Add keyboard shortcuts
- [ ] Implement auto-reconnect logic

### Phase 8: Testing & Deployment
- [ ] Write unit tests (Jest)
- [ ] Write integration tests
- [ ] Write E2E tests (Playwright)
- [ ] Set up CI/CD pipeline
- [ ] Configure electron-builder for production builds
- [ ] Deploy backend server to production

## Current Status
**Phase:** Project Structure Complete - Ready for Implementation

The RoChat project has been fully structured with all necessary directories and files created. The Memory Bank contains comprehensive documentation about the project architecture, requirements, and technical context. All files are empty and ready for implementation.

## Known Issues
None - No code has been written yet.

## Evolution of Project Decisions

### January 20, 2026 - Project Initialization
- Project structure established with Electron + Express architecture
- Dual-method detection approach decided (logs + memory scanning)
- Technology stack selected: Electron, Node.js, Express, MongoDB/PostgreSQL (TBD)
- Comprehensive Memory Bank documentation created
- Git repository configured

### Architecture Decisions Made
- **Electron** chosen for cross-platform desktop application
- **Express.js** for backend REST API
- **MongoDB or PostgreSQL** for data persistence (decision pending)
- **electron-store** for encrypted local storage
- **Dual-method detection** for Roblox chat reliability
- **JWT-based authentication** for API security

## Completed Milestones
- ✅ Project initialization
- ✅ Memory Bank setup with comprehensive documentation
- ✅ Git repository configuration
- ✅ Complete directory structure created (28 files)
- ✅ Architecture designed and documented
- ✅ Technology stack defined
- ✅ Development workflow established

## In Progress
- Preparing for Phase 1: Foundation Setup
- Ready to initialize npm package and install dependencies

## Blocked On
- **Database selection:** Need to choose between MongoDB and PostgreSQL
- **Frontend framework decision:** Vanilla JS vs React/Vue (current choice: Vanilla JS)
- **TypeScript adoption:** Decide now or migrate later

## Next Immediate Steps

### Priority 1 (Immediate - Today)
1. Initialize npm project with `npm init`
2. Install Electron dependencies: `npm install electron`
3. Install backend dependencies: `npm install express jsonwebtoken`
4. Install storage dependency: `npm install electron-store`
5. Create package.json scripts (start, build, dev)

### Priority 2 (This Week)
1. Set up ESLint and Prettier
2. Create basic Electron main process
3. Create simple renderer window
4. Set up Express server
5. Configure database connection

### Priority 3 (Next Week)
1. Implement process detection
2. Create authentication flow
3. Build basic UI views
4. Connect IPC communication
5. Test end-to-end flow

## Project Metrics
**Lines of Code:** 0 (empty files ready for implementation)
**Files Created:** 28 (directory structure complete)
**Features Implemented:** 0 (structure ready)
**Tests Written:** 0
**Known Bugs:** 0
**Documentation Coverage:** 100% (all memory bank files complete)

## Notes
This file will be updated regularly to track:
- Completed features and functionality
- Outstanding work and TODOs
- Known issues and bugs
- Evolution of architectural decisions
- Progress toward project milestones
- Current phase and next steps

## Development Progress Bar
```
Phase 1: Foundation Setup          [░░░░░░░░░░]   0%
Phase 2: Electron Main Process     [░░░░░░░░░░]   0%
Phase 3: Detection Module           [░░░░░░░░░░]   0%
Phase 4: Backend Server            [░░░░░░░░░░]   0%
Phase 5: Renderer UI                [░░░░░░░░░░]   0%
Phase 6: Integration & Testing      [░░░░░░░░░░]   0%
Phase 7: Polish & Features         [░░░░░░░░░░]   0%
Phase 8: Testing & Deployment      [░░░░░░░░░░]   0%

Overall Progress: [░░░░░░░░░░]   0% (Structure complete, implementation pending)
</file>

<file path="memory_bank/projectbrief.md">
# Project Brief: RoChat

## Project Overview
**Project Name:** RoChat
**Status:** Structure Created - January 20, 2026
**Type:** Desktop Application (Electron) with Backend Server

## Core Requirements
- [x] Create project structure
- [ ] Implement Roblox process detection (log monitoring + memory scanning)
- [ ] Implement Roblox authentication (OAuth/cookie login)
- [ ] Build secure token management
- [ ] Create chat relay functionality
- [ ] Build desktop UI (login, chat, settings)
- [ ] Implement theme support
- [ ] Set up backend API with authentication middleware
- [ ] Configure database (MongoDB/PostgreSQL)

## Project Goals
- Create a desktop chat application for Roblox
- Provide secure authentication via Roblox OAuth/cookies
- Enable in-game chat detection and relay
- Maintain encrypted local storage for credentials
- Build scalable backend for chat routing
- Ensure clean, maintainable codebase

## Success Criteria
- Successfully detect Roblox game sessions
- Securely authenticate with Roblox
- Relay in-game chat to the application
- Persist user data securely
- Responsive and intuitive UI

## Technical Scope
- **Frontend:** Electron (Chromium + Node.js)
- **Backend:** Node.js/Express server
- **Database:** MongoDB or PostgreSQL
- **Storage:** electron-store (encrypted)
- **Platform:** Desktop (Windows initially)

## Target Users
Roblox players who want to:
- View in-game chat outside the game
- Have persistent chat history
- Use a dedicated desktop application for Roblox communication
- Manage multiple Roblox sessions

## Notes
Project structure has been established. All files are empty and ready for implementation.

## Questions Addressed
- **Type of chat:** Roblox in-game chat relay application
- **Platform:** Desktop application (Electron)
- **Target audience:** Roblox players
- **Key features:** Process detection, authentication, chat relay, secure storage
- **Technologies:** Electron, Node.js, MongoDB/PostgreSQL, electron-store
</file>

<file path="memory_bank/systemPatterns.md">
# System Patterns: RoChat

## System Architecture
RoChat follows a **hybrid architecture** combining:
- **Electron Main Process:** Node.js backend for system-level operations
- **Electron Renderer Process:** Chromium-based UI for user interface
- **Express Backend Server:** RESTful API for chat relay and authentication
- **Database Layer:** MongoDB or PostgreSQL for persistent data storage

```
┌─────────────────────────────────────────────────────────────┐
│                         Electron App                        │
├─────────────────────────────────────────────────────────────┤
│  Renderer Process          │     Main Process               │
│  ┌─────────────────────┐   │  ┌─────────────────────────┐ │
│  │   Views (HTML)      │   │  │  Detection Module       │ │
│  │   - login.html      │   │  │  - logMonitor.js        │ │
│  │   - chat.html       │   │  │  - memoryReader.js      │ │
│  │   - settings.html   │   │  │  - processWatcher.js    │ │
│  ├─────────────────────┤   │  │  - detector.js          │ │
│  │   UI Logic (JS)     │   │  ├─────────────────────────┤ │
│  │   - app.js          │   │  │  Auth Module            │ │
│  │   - chat.js         │   │  │  - robloxAuth.js        │ │
│  │   - settings.js     │   │  │  - tokenManager.js      │ │
│  ├─────────────────────┤   │  ├─────────────────────────┤ │
│  │   Styles (CSS)      │   │  │  Storage Module         │ │
│  │   - main.css        │   │  │  - secureStore.js       │ │
│  │   - themes.css      │   │  ├─────────────────────────┤ │
│  └─────────────────────┘   │  │  IPC Handlers           │ │
│                            │  │  - handlers.js           │ │
└────────────────────────────┼────────────────────────────┼─┘
                             │   IPC Communication       │
                             └───────────┬───────────────┘
                                         │
                              ┌──────────▼──────────┐
                              │  Express Server     │
                              ├────────────────────┤
                              │  Routes            │
                              │  - chat.js         │
                              │  - auth.js         │
                              ├────────────────────┤
                              │  Middleware        │
                              │  - authMiddleware  │
                              └──────────┬─────────┘
                                         │
                              ┌──────────▼──────────┐
                              │  Database          │
                              │  MongoDB/PostgreSQL│
                              ├────────────────────┤
                              │  Models            │
                              │  - User.js         │
                              │  - Message.js      │
                              └────────────────────┘
```

## Key Technical Decisions

### Detection Strategy (Dual-Method)
**Primary:** Log monitoring - Parse Roblox log files for chat events
**Fallback:** Memory scanning - Scan process memory when logs are unavailable
**Reasoning:** Provides reliability across different Roblox versions and scenarios

### Authentication Flow
1. User initiates login via OAuth or provides cookies
2. Roblox API authenticates and returns tokens
3. Tokens are securely stored in electron-store (encrypted)
4. Token manager handles refresh cycles automatically
5. IPC communicates auth state between main and renderer processes

### Data Flow
1. **Detection:** Process watcher detects RobloxPlayerBeta.exe
2. **Extraction:** Log monitor or memory reader extracts chat messages
3. **Transmission:** IPC sends messages to renderer process
4. **Display:** Chat UI renders messages in real-time
5. **Persistence:** Backend server stores messages in database
6. **Sync:** Server synchronizes chat history across sessions

## Design Patterns in Use

### Module Pattern
Each major component is an independent module:
- Detection module handles all process monitoring
- Auth module manages authentication flows
- Storage module handles encrypted data persistence

### Observer Pattern
Process watcher observes Roblox process state changes
Log monitor observes log file changes
Chat UI observes message updates via IPC

### Singleton Pattern
Secure store instance is a singleton for consistent access
Token manager maintains single source of truth for authentication

### Factory Pattern
Detector factory creates appropriate detection method based on environment

## Component Relationships

### Detection Module Dependencies
- `detector.js` orchestrates `logMonitor.js`, `memoryReader.js`, and `processWatcher.js`
- `processWatcher.js` triggers detection when Roblox starts/stops
- Detection results are sent via IPC to renderer

### Authentication Module Dependencies
- `robloxAuth.js` handles OAuth flows and cookie validation
- `tokenManager.js` manages token lifecycle (issue, refresh, revoke)
- `secureStore.js` persists encrypted credentials

### IPC Communication
- Main process exposes APIs via `handlers.js`
- Renderer process invokes APIs via `ipcRenderer`
- Shared constants define IPC channel names

## Critical Implementation Paths

### Startup Flow
1. Electron main process initializes
2. Process watcher starts monitoring for Roblox
3. Renderer loads login view
4. User authenticates via OAuth/cookies
5. Tokens stored securely
6. App switches to chat view

### Detection Flow
1. `processWatcher.js` detects RobloxPlayerBeta.exe
2. `detector.js` selects detection method
3. `logMonitor.js` reads log files (primary)
4. Or `memoryReader.js` scans memory (fallback)
5. Chat messages extracted and parsed
6. IPC sends messages to renderer

### Chat Relay Flow
1. Detection module extracts message
2. Main process forwards to backend server
3. Backend stores in database
4. Backend broadcasts to connected clients
5. Renderer receives via WebSocket/HTTP
6. Chat UI displays message

## Security Considerations

### Credential Storage
- All tokens encrypted using system keychain (Windows Credential Manager)
- electron-store configured with encryption enabled
- Memory cleared of sensitive data after use

### IPC Security
- Validated IPC channels only
- Input sanitization on all IPC messages
- No sensitive data in renderer process memory

### API Security
- JWT-based authentication
- Auth middleware on all protected routes
- HTTPS only for production deployment

## Scalability Patterns

### Detection Layer
- Event-driven architecture for process monitoring
- Non-blocking I/O for log reading
- Polling with adaptive intervals

### Backend Layer
- RESTful API design for horizontal scaling
- Database connection pooling
- Optional WebSocket for real-time updates

### Storage Layer
- Encrypted local storage for offline capability
- Cloud database for cross-device sync
- Lazy loading for chat history

## Performance Patterns

### Detection Optimization
- Tail-call optimization in log parsing
- Binary search for memory pattern matching
- Debouncing for rapid state changes

### UI Optimization
- Virtual scrolling for long chat histories
- CSS containment for theme switching
- Debounced input handling

### Data Optimization
- Message batching for network efficiency
- Delta updates for chat history
- Indexed patterns for memory scanning

## Notes
This architecture prioritizes security, reliability, and performance while maintaining clean separation of concerns between the Electron app and backend server.

## Future Considerations
- Add WebSocket support for real-time server push
- Implement message queuing for offline scenarios
- Consider Redis for caching active sessions
- Add rate limiting for API endpoints
</file>

<file path="memory_bank/techContext.md">
# Tech Context: RoChat

## Technologies Used

### Frontend / Desktop
- **Electron:** Cross-platform desktop application framework
- **HTML5/CSS3:** UI markup and styling
- **Vanilla JavaScript:** Renderer process logic (no framework initially)

### Backend
- **Node.js:** JavaScript runtime for main and server processes
- **Express.js:** Web server framework for API
- **MongoDB or PostgreSQL:** Database for persistent storage (TBD)

### Libraries & Tools
- **electron-store:** Encrypted local storage for Electron
- **node-fetch:** HTTP requests for Roblox API
- **JWT:** Token generation and validation
- **bcrypt:** Password hashing (if needed)

### Development Tools
- **electron-builder:** Application packaging and distribution
- **ESLint:** Code linting
- **Prettier:** Code formatting

## Development Setup

### Prerequisites
- Node.js (v18+)
- npm or yarn
- MongoDB or PostgreSQL (choice to be made)
- Git

### Installation Commands (to be implemented)
```bash
# Clone repository
git clone <repository-url>
cd RoChat

# Install dependencies
npm install

# Start backend server
npm run server

# Start Electron app
npm run electron
```

### Environment Configuration
Create `.env` file with:
```
# Database
DB_URL=mongodb://localhost:27017/rochat
# or
DB_URL=postgresql://user:password@localhost:5432/rochat

# Server
PORT=3000

# Security
JWT_SECRET=your-secret-key

# Roblox
ROBLOX_CLIENT_ID=your-client-id
ROBLOX_CLIENT_SECRET=your-client-secret
```

## Technical Constraints

### Platform-Specific
- **Initial Target:** Windows 10/11
- **Future:** macOS, Linux support (electron-builder handles cross-platform)

### Roblox Integration
- Must use approved detection methods (log parsing, memory reading)
- Cannot modify Roblox client files
- Must respect Roblox Terms of Service

### Security
- All credentials must be encrypted at rest
- IPC communication must be validated and sanitized
- API endpoints require authentication
- No sensitive data in client-side code

## Dependencies

### Production Dependencies (to be installed)
```json
{
  "electron": "^latest",
  "express": "^latest",
  "electron-store": "^latest",
  "node-fetch": "^latest",
  "jsonwebtoken": "^latest",
  "bcrypt": "^latest"
}
```

### Database Dependencies (to be selected)
- MongoDB: `mongoose` or `mongodb`
- PostgreSQL: `pg` and `sequelize`

### Development Dependencies (to be installed)
```json
{
  "electron-builder": "^latest",
  "eslint": "^latest",
  "prettier": "^latest"
}
```

## Tool Usage Patterns

### Version Control
- **Branch Strategy:** Git Flow (main, develop, feature branches)
- **Commit Convention:** Conventional Commits (feat:, fix:, docs:, etc.)
- **Repository:** GitHub (private)

### Code Quality
- **Linting:** ESLint for JavaScript
- **Formatting:** Prettier with consistent configuration
- **Type Safety:** Consider TypeScript for future refactoring

### Testing
- **Framework:** Jest for unit testing
- **E2E:** Playwright for Electron testing
- **Coverage:** Target 80%+ coverage

## Environment Configuration

### Development
- Hot reload enabled for renderer process
- Debug logging enabled
- Local database instance

### Production
- Optimized builds (minification, tree-shaking)
- Production database
- Encrypted builds (code signing)

### Environment Variables
All sensitive data stored in `.env` (gitignored)
Template provided in `.env.example`

## Build and Deployment

### Build Process
```bash
# Build for current platform
npm run build

# Build for Windows
npm run build:win

# Build for macOS
npm run build:mac

# Build for Linux
npm run build:linux
```

### Distribution
- **Windows:** NSIS installer and portable exe
- **macOS:** DMG and app bundle
- **Linux:** AppImage and deb

### Server Deployment
- **Platform:** VPS or cloud provider (AWS, DigitalOcean, etc.)
- **Process Manager:** PM2 or systemd
- **Reverse Proxy:** Nginx
- **SSL:** Let's Encrypt

## Testing Strategy

### Unit Testing
- Jest for Node.js modules
- Mock Electron APIs in renderer tests
- Test coverage: 80%+ minimum

### Integration Testing
- Test IPC communication between main and renderer
- Test API endpoints with Express
- Test database operations

### End-to-End Testing
- Playwright for Electron UI automation
- Test complete user flows (login, chat relay, settings)
- Test Roblox detection scenarios

## Code Style and Linting

### ESLint Configuration
```json
{
  "extends": ["eslint:recommended"],
  "env": {
    "browser": true,
    "node": true,
    "es2021": true
  },
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  }
}
```

### Prettier Configuration
```json
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

### Naming Conventions
- Files: camelCase (JavaScript modules)
- Components: PascalCase (if React added later)
- Functions: camelCase
- Constants: UPPER_SNAKE_CASE
- CSS: kebab-case for classes/IDs

## Version Control

### Git Workflow
- `main` - Production releases
- `develop` - Integration branch
- `feature/*` - Feature branches
- `bugfix/*` - Bug fix branches

### Commit Messages
```
feat: add Roblox OAuth authentication
fix: resolve memory scanner crash
docs: update README with setup instructions
style: format code with Prettier
refactor: optimize log parser performance
test: add unit tests for token manager
chore: update dependencies
```

## Environment Details
- **Operating System:** Windows 11
- **IDE:** Visual Studio Code
- **Shell:** C:\Windows\system32\cmd.exe
- **Home Directory:** C:\Users\moham
- **Working Directory:** d:\RoChat

## Available CLI Tools
- git
- docker
- kubectl
- npm
- pip
- cargo
- curl
- python
- node
- code
- dotnet

## Future Considerations
- **TypeScript:** Consider migration for type safety
- **Framework:** React or Vue for complex UI (if needed)
- **State Management:** Redux or Zustand if state becomes complex
- **Real-time:** Socket.io for WebSocket support
- **Database:** Final choice between MongoDB and PostgreSQL
- **Testing:** Add E2E testing framework once core features complete
- **CI/CD:** GitHub Actions or GitLab CI for automated testing/deployment
</file>

<file path="package.json">
{
  "name": "rochat",
  "version": "1.0.0",
  "description": "Roblox Chat Relay Application",
  "main": "src/main/index.js",
  "scripts": {
    "start": "electron .",
    "dev": "electron . --development",
    "build": "electron-builder",
    "server": "node server/index.js",
    "dev:server": "nodemon server/index.js"
  },
  "keywords": [
    "roblox",
    "chat",
    "electron",
    "desktop"
  ],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "electron": "^28.0.0",
    "electron-builder": "^24.9.1",
    "nodemon": "^3.0.2"
  },
  "dependencies": {
    "dotenv": "^16.3.1",
    "electron-store": "^8.1.0",
    "express": "^4.18.2",
    "mongoose": "^8.0.3",
    "socket.io": "^4.6.0",
    "winston": "^3.11.0",
    "axios": "^1.6.5"
  },
  "build": {
    "appId": "com.rochat.app",
    "productName": "RoChat",
    "directories": {
      "output": "dist"
    },
    "files": [
      "src/**/*",
      "package.json"
    ],
    "win": {
      "target": "nsis",
      "icon": "build/icon.ico"
    },
    "mac": {
      "target": "dmg",
      "icon": "build/icon.icns"
    },
    "linux": {
      "target": "AppImage",
      "icon": "build/icon.png"
    }
  }
}
</file>

<file path="README.md">
# RoChat

Roblox Chat Relay Application - An Electron-based desktop application for monitoring and relaying Roblox chat messages.

## Features

- Roblox Authentication (OAuth/Token-based)
- Real-time server detection (JobId/PlaceId)
- Chat monitoring and relaying
- Secure token storage (electron-store)
- WebSocket-based real-time communication
- Cross-platform support (Windows, macOS, Linux)

## Architecture

The application consists of two main components:

1. **Electron Client** - Desktop application for monitoring Roblox and displaying chat
2. **Express Server** - Backend server for chat relay and authentication

### Electron Client Structure

```
src/
├── main/           # Electron main process
│   ├── detection/   # Roblox detection (log monitoring, memory reading)
│   ├── auth/        # Authentication (Roblox login, token management)
│   ├── storage/     # Secure storage (electron-store)
│   ├── ipc/         # IPC communication handlers
│   └── logging/     # Logging (winston)
├── renderer/        # Renderer process (UI)
│   ├── js/          # JavaScript logic
│   ├── css/         # Stylesheets
│   └── index.html   # Main HTML
├── preload/         # Preload script for context isolation
└── shared/          # Shared utilities and constants
```

### Server Structure

```
server/
├── config/          # Database configuration
├── middleware/      # Express middleware
├── models/          # Mongoose models
├── routes/          # API routes
└── logging/         # Server logging
```

## Installation

1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   ```

## Configuration

1. Copy `.env.example` to `.env`:
   ```bash
   cp .env.example .env
   ```

2. Edit `.env` with your configuration:
   - `DB_URL` - MongoDB connection string
   `PORT` - Server port (default: 3000)
   `JWT_SECRET` - Secret key for JWT tokens

## Running the Application

### Development

1. Start the server:
   ```bash
   npm run dev:server
   ```

2. In another terminal, start the Electron app:
   ```bash
   npm run dev
   ```

### Production

1. Build the application:
   ```bash
   npm run build
   ```

2. Run the built application from the `dist/` directory

## How It Works

1. **Authentication**: User logs in with Roblox credentials
2. **Detection**: The app monitors Roblox logs to detect game server (JobId/PlaceId)
3. **Connection**: App connects to the backend server using the detected JobId
4. **Chat Relay**: Messages are relayed between the app and the server via WebSocket

## Security Notes

- All sensitive data is stored using `electron-store` with encryption
- Roblox tokens are never exposed to the renderer process
- IPC communication uses context isolation for security

## Dependencies

### Electron
- `electron` - Desktop application framework
- `electron-store` - Secure persistent storage

### Server
- `express` - Web framework
- `mongoose` - MongoDB ODM
- `socket.io` - WebSocket library
- `winston` - Logging library
- `axios` - HTTP client

## License

MIT
</file>

<file path="server/config/database.js">
const mongoose = require('mongoose');
const logger = require('../logging/logger');

const MONGODB_URI = process.env.DB_URL || 'mongodb://localhost:27017/rochat';

/**
 * Connect to MongoDB
 */
async function connectDatabase() {
  try {
    await mongoose.connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    
    logger.info('Connected to MongoDB');
    
    mongoose.connection.on('error', (error) => {
      logger.error('MongoDB connection error', { error: error.message });
    });
    
    mongoose.connection.on('disconnected', () => {
      logger.warn('MongoDB disconnected');
    });
    
    process.on('SIGINT', async () => {
      await mongoose.connection.close();
      logger.info('MongoDB connection closed through app termination');
      process.exit(0);
    });
  } catch (error) {
    logger.error('Failed to connect to MongoDB', { error: error.message });
    process.exit(1);
  }
}

module.exports = connectDatabase;
</file>

<file path="server/index.js">
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const logger = require('./logging/logger');
const authRoutes = require('./routes/auth');
const chatRoutes = require('./routes/chat');
const authMiddleware = require('./middleware/authMiddleware');

const app = express();
const server = http.createServer(app);

// Initialize Socket.io
const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST']
  }
});

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Make io available to routes
app.set('io', io);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/chat', authMiddleware, chatRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: Date.now() });
});

// Socket.io connection handling
io.on('connection', (socket) => {
  logger.info('Client connected', { socketId: socket.id });

  socket.on('join-room', (jobId) => {
    socket.join(jobId);
    logger.info('Client joined room', { socketId: socket.id, jobId });
  });

  socket.on('leave-room', (jobId) => {
    socket.leave(jobId);
    logger.info('Client left room', { socketId: socket.id, jobId });
  });

  socket.on('disconnect', () => {
    logger.info('Client disconnected', { socketId: socket.id });
  });
});

// Export io for use in routes
module.exports.io = io;

const PORT = process.env.PORT || 3000;

server.listen(PORT, () => {
  logger.info(`Server listening on port ${PORT}`);
});
</file>

<file path="server/logging/logger.js">
const winston = require('winston');

const isDevelopment = process.env.NODE_ENV !== 'production';

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.printf(({ timestamp, level, message, ...metadata }) => {
    let msg = `${timestamp} [${level.toUpperCase()}]: ${message}`;
    if (Object.keys(metadata).length > 0) {
      msg += ` ${JSON.stringify(metadata)}`;
    }
    return msg;
  })
);

// Create logger instance
const logger = winston.createLogger({
  level: isDevelopment ? 'debug' : 'info',
  format: logFormat,
  transports: [
    // Console transport (colorized in development)
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        logFormat
      )
    }),
    // File transport - all logs
    new winston.transports.File({
      filename: 'logs/server.log',
      maxsize: 5 * 1024 * 1024, // 5MB
      maxFiles: 5
    }),
    // Error file transport - errors only
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5 * 1024 * 1024, // 5MB
      maxFiles: 5
    })
  ]
});

module.exports = logger;
</file>

<file path="server/middleware/authMiddleware.js">
const logger = require('../logging/logger');
const User = require('../models/User');

/**
 * Verify Roblox token and authenticate user
 */
async function authMiddleware(req, res, next) {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ 
        success: false, 
        error: 'No authorization token provided' 
      });
    }

    const token = authHeader.substring(7); // Remove 'Bearer ' prefix

    // TODO: Verify Roblox token
    // For now, we'll just extract userId from token payload
    // In production, you would verify the token with Roblox API
    
    // Simplified token parsing (JWT-like)
    let payload;
    try {
      // This is a placeholder - implement proper token verification
      const tokenParts = token.split('.');
      if (tokenParts.length === 3) {
        payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());
      } else {
        // For non-JWT tokens, we'd need a different approach
        return res.status(401).json({ 
          success: false, 
          error: 'Invalid token format' 
        });
      }
    } catch (error) {
      logger.error('Failed to parse token', { error: error.message });
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid token' 
      });
    }

    // Find user by userId
    const user = await User.findOne({ userId: payload.userId });
    
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        error: 'User not found' 
      });
    }

    // Attach user to request
    req.user = user;
    next();
  } catch (error) {
    logger.error('Auth middleware error', { error: error.message });
    return res.status(500).json({ 
      success: false, 
      error: 'Authentication failed' 
    });
  }
}

module.exports = authMiddleware;
</file>

<file path="server/models/Message.js">
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  jobId: {
    type: String,
    required: true,
    index: true
  },
  userId: {
    type: Number,
    required: true,
    index: true
  },
  username: {
    type: String,
    required: true
  },
  message: {
    type: String,
    required: true,
    maxlength: 200 // Limit message length
  }
}, {
  timestamps: true
});

// Index for efficient queries
messageSchema.index({ jobId: 1, createdAt: -1 });

module.exports = mongoose.model('Message', messageSchema);
</file>

<file path="server/models/User.js">
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  userId: {
    type: Number,
    required: true,
    unique: true,
    index: true
  },
  username: {
    type: String,
    required: true
  },
  displayName: {
    type: String
  },
  robloxToken: {
    type: String,
    select: false // Never return token in queries by default
  },
  lastSeen: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Update lastSeen timestamp before saving
userSchema.pre('save', function(next) {
  this.lastSeen = new Date();
  next();
});

// Index for efficient queries
userSchema.index({ userId: 1 });

module.exports = mongoose.model('User', userSchema);
</file>

<file path="server/routes/auth.js">
const express = require('express');
const router = express.Router();
const logger = require('../logging/logger');
const User = require('../models/User');
const axios = require('axios');

/**
 * Verify Roblox token and return user info
 */
router.post('/verify', async (req, res) => {
  try {
    const { token } = req.body;

    if (!token) {
      return res.status(400).json({ 
        success: false, 
        error: 'Token is required' 
      });
    }

    // Verify token with Roblox API
    const userResponse = await axios.get('https://users.roblox.com/v1/users/authenticated', {
      headers: {
        'Authorization': `Bearer ${token}`,
        'User-Agent': 'RoChat/1.0'
      }
    });

    if (userResponse.status !== 200 || !userResponse.data) {
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid token' 
      });
    }

    const { id, name, displayName } = userResponse.data;

    // Find or create user
    let user = await User.findOne({ userId: id });

    if (!user) {
      user = new User({
        userId: id,
        username: name,
        displayName: displayName,
        robloxToken: token
      });
      await user.save();
      logger.info('New user created', { userId: id, username: name });
    } else {
      // Update user info
      user.username = name;
      user.displayName = displayName;
      user.robloxToken = token;
      await user.save();
      logger.info('User updated', { userId: id, username: name });
    }

    res.json({
      success: true,
      user: {
        userId: user.userId,
        username: user.username,
        displayName: user.displayName
      }
    });
  } catch (error) {
    logger.error('Auth verification failed', { error: error.message });

    if (error.response && error.response.status === 401) {
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid Roblox token' 
      });
    }

    res.status(500).json({ 
      success: false, 
      error: 'Verification failed' 
    });
  }
});

/**
 * Get user info by ID (requires auth)
 */
router.get('/user', async (req, res) => {
  try {
    const { userId } = req.query;

    if (!userId) {
      return res.status(400).json({ 
        success: false, 
        error: 'User ID is required' 
      });
    }

    const user = await User.findOne({ userId });

    if (!user) {
      return res.status(404).json({ 
        success: false, 
        error: 'User not found' 
      });
    }

    res.json({
      success: true,
      user: {
        userId: user.userId,
        username: user.username,
        displayName: user.displayName
      }
    });
  } catch (error) {
    logger.error('Failed to get user', { error: error.message });
    res.status(500).json({ 
      success: false, 
      error: 'Failed to get user' 
    });
  }
});

module.exports = router;
</file>

<file path="server/routes/chat.js">
const express = require('express');
const router = express.Router();
const logger = require('../logging/logger');
const Message = require('../models/Message');
const axios = require('axios');

/**
 * Send a chat message
 */
router.post('/send', async (req, res) => {
  try {
    const { jobId, message } = req.body;
    const { userId, username } = req.user;

    if (!jobId || !message) {
      return res.status(400).json({ 
        success: false, 
        error: 'JobId and message are required' 
      });
    }

    if (message.length > 200) {
      return res.status(400).json({ 
        success: false, 
        error: 'Message too long (max 200 characters)' 
      });
    }

    // Save message to database
    const newMessage = new Message({
      jobId,
      userId,
      username,
      message
    });
    await newMessage.save();

    // Get Socket.io instance from app
    const io = req.app.get('io');

    // Broadcast message to all clients in the room
    io.to(jobId).emit('message', {
      jobId,
      userId,
      username,
      message,
      timestamp: newMessage.createdAt
    });

    // Send message to Roblox (TODO - need to implement)
    // This would send the message through Roblox's chat API
    await sendToRoblox(jobId, message, req.user.robloxToken);

    logger.info('Message sent', { jobId, userId, username });

    res.json({
      success: true,
      message: {
        jobId,
        userId,
        username,
        message,
        timestamp: newMessage.createdAt
      }
    });
  } catch (error) {
    logger.error('Failed to send message', { error: error.message });
    res.status(500).json({ 
      success: false, 
      error: 'Failed to send message' 
    });
  }
});

/**
 * Get chat history for a JobId
 */
router.get('/history', async (req, res) => {
  try {
    const { jobId, limit = 50, before } = req.query;

    if (!jobId) {
      return res.status(400).json({ 
        success: false, 
        error: 'JobId is required' 
      });
    }

    const query = { jobId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const messages = await Message.find(query)
      .sort({ createdAt: -1 })
      .limit(parseInt(limit));

    res.json({
      success: true,
      messages: messages.reverse() // Return in chronological order
    });
  } catch (error) {
    logger.error('Failed to get chat history', { error: error.message });
    res.status(500).json({ 
      success: false, 
      error: 'Failed to get chat history' 
    });
  }
});

/**
 * Receive chat message from Roblox
 * This endpoint would be called by a script running in Roblox
 * or by monitoring Roblox logs (would be in main process)
 */
router.post('/receive', async (req, res) => {
  try {
    const { jobId, userId, username, message, timestamp } = req.body;

    if (!jobId || !userId || !username || !message) {
      return res.status(400).json({ 
        success: false, 
        error: 'Missing required fields' 
      });
    }

    // Save message to database
    const newMessage = new Message({
      jobId,
      userId,
      username,
      message,
      createdAt: timestamp ? new Date(timestamp) : new Date()
    });
    await newMessage.save();

    // Get Socket.io instance from app
    const io = req.app.get('io');

    // Broadcast message to all clients in the room
    io.to(jobId).emit('message', {
      jobId,
      userId,
      username,
      message,
      timestamp: newMessage.createdAt
    });

    logger.info('Message received', { jobId, userId, username });

    res.json({ success: true });
  } catch (error) {
    logger.error('Failed to receive message', { error: error.message });
    res.status(500).json({ 
      success: false, 
      error: 'Failed to receive message' 
    });
  }
});

/**
 * Send message to Roblox
 * TODO: Implement actual Roblox chat API integration
 */
async function sendToRoblox(jobId, message, token) {
  try {
    // This is a placeholder - implement actual Roblox chat sending
    // Roblox doesn't provide a public API for sending chat messages
    // This would require a more complex approach (e.g., memory injection, etc.)
    
    logger.info('Sending to Roblox (placeholder)', { jobId, message });
    
    // For now, just log - actual implementation would be complex
    // and may require research into Roblox's internal systems
    
    return true;
  } catch (error) {
    logger.error('Failed to send to Roblox', { error: error.message });
    return false;
  }
}

module.exports = router;
</file>

<file path="src/main/auth/robloxAuth.js">
const { BrowserWindow } = require('electron');
const axios = require('axios');
const logger = require('../logging/logger');
const secureStore = require('../storage/secureStore');

/**
 * Initiate Roblox login using cookie-based authentication
 */
async function initiateLogin() {
  return new Promise((resolve, reject) => {
    logger.info('Initiating Roblox cookie login');
    
    const loginWindow = new BrowserWindow({
      width: 800,
      height: 600,
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        partition: 'persist:roblox' // Separate cookie store for Roblox
      }
    });
    
    loginWindow.loadURL('https://www.roblox.com/login');
    
    // Show window when loaded
    loginWindow.once('ready-to-show', () => {
      loginWindow.show();
    });
    
    // Check for successful login every 2 seconds
    const checkLogin = setInterval(async () => {
      try {
        const cookies = await loginWindow.webContents.session.cookies.get({
          url: 'https://www.roblox.com',
          name: '.ROBLOSECURITY'
        });
        
        if (cookies.length > 0) {
          clearInterval(checkLogin);
          const token = cookies[0].value;
          
          // Get user info with cookie
          const userInfo = await getUserInfoWithCookie(token);
          
          // Save auth data
          const authData = {
            robloxToken: token,
            userId: userInfo.id,
            username: userInfo.name,
            displayName: userInfo.displayName,
            expiresAt: Date.now() + (365 * 24 * 60 * 60 * 1000) // 1 year
          };
          
          secureStore.saveAuth(authData);
          loginWindow.close();
          
          logger.info('Login successful', { username: userInfo.name });
          resolve(userInfo);
        }
      } catch (error) {
        logger.error('Error checking login', { error: error.message });
      }
    }, 2000);
    
    // Handle login window closed
    loginWindow.on('closed', () => {
      clearInterval(checkLogin);
      reject(new Error('Login cancelled'));
    });
  });
}

/**
 * Get user information using cookie
 */
async function getUserInfoWithCookie(cookie) {
  const response = await axios.get('https://users.roblox.com/v1/users/authenticated', {
    headers: {
      'Cookie': `.ROBLOSECURITY=${cookie}`,
      'User-Agent': 'RoChat/1.0'
    }
  });
  
  return {
    id: response.data.id,
    name: response.data.name,
    displayName: response.data.displayName
  };
}

/**
 * Check if user is authenticated
 */
function isAuthenticated() {
  const auth = secureStore.getAuth();
  
  if (!auth) {
    return false;
  }
  
  // Check if token is expired
  if (Date.now() >= auth.expiresAt) {
    logger.info('Token expired');
    secureStore.clearAuth();
    return false;
  }
  
  return true;
}

/**
 * Get current user info
 */
function getCurrentUser() {
  const auth = secureStore.getAuth();
  
  if (!auth || Date.now() >= auth.expiresAt) {
    return null;
  }
  
  return {
    userId: auth.userId,
    username: auth.username,
    displayName: auth.displayName
  };
}

module.exports = {
  initiateLogin,
  isAuthenticated,
  getCurrentUser
};
</file>

<file path="src/main/auth/tokenManager.js">
const logger = require('../logging/logger');
const secureStore = require('../storage/secureStore');

/**
 * Logout user by clearing authentication data
 */
function logout() {
  try {
    logger.info('Logging out user');
    secureStore.clearAuth();
    return true;
  } catch (error) {
    logger.error('Logout failed', { error: error.message });
    return false;
  }
}

/**
 * Get valid token from storage
 * Roblox cookies don't have refresh tokens
 */
function getValidToken() {
  const auth = secureStore.getAuth();
  
  if (!auth) {
    return null;
  }
  
  // Cookies are long-lived, just check if expired
  if (Date.now() >= auth.expiresAt) {
    logger.info('Token expired, user must re-login');
    secureStore.clearAuth();
    return null;
  }
  
  return auth.robloxToken;
}

/**
 * Check if user has a valid token
 */
function hasValidToken() {
  const auth = secureStore.getAuth();
  
  if (!auth) {
    return false;
  }
  
  // Check if token is expired
  if (Date.now() >= auth.expiresAt) {
    return false;
  }
  
  return true;
}

module.exports = {
  logout,
  getValidToken,
  hasValidToken
};
</file>

<file path="src/main/detection/detector.js">
const { EventEmitter } = require('events');
const processWatcher = require('./processWatcher');
const logMonitor = require('./logMonitor');
const memoryReader = require('./memoryReader');
const logger = require('../logging/logger');

class Detector extends EventEmitter {
  constructor() {
    super();
    this.currentServer = null; // { placeId, jobId, timestamp }
    this.lastLogUpdate = null;
    this.memoryFallbackTimeout = null;
    this.isRunning = false;
  }

  /**
   * Start the detector
   * Watches for Roblox process and monitors logs
   */
  start() {
    if (this.isRunning) {
      logger.warn('Detector already running');
      return;
    }

    logger.info('Starting detector');
    this.isRunning = true;

    // Start process watcher
    processWatcher.startWatching();

    // Listen for process events
    processWatcher.on('processStarted', () => {
      logger.info('Roblox process started, starting log monitor');
      this.handleProcessStarted();
    });

    processWatcher.on('processStopped', () => {
      logger.info('Roblox process stopped');
      this.handleProcessStopped();
    });

    // Listen for log monitor events
    logMonitor.on('serverDetected', (serverInfo) => {
      this.handleServerDetected(serverInfo, 'log');
    });
  }

  /**
   * Stop the detector
   */
  stop() {
    if (!this.isRunning) {
      logger.warn('Detector not running');
      return;
    }

    logger.info('Stopping detector');
    this.isRunning = false;

    // Stop all watchers
    processWatcher.stopWatching();
    logMonitor.stopMonitoring();

    // Clear any pending timeouts
    if (this.memoryFallbackTimeout) {
      clearTimeout(this.memoryFallbackTimeout);
      this.memoryFallbackTimeout = null;
    }
  }

  /**
   * Handle Roblox process started
   */
  handleProcessStarted() {
    // Clear current server
    this.currentServer = null;
    this.lastLogUpdate = Date.now();

    // Start log monitoring
    logMonitor.startMonitoring();

    // Set up memory fallback timeout (10 seconds)
    // If no log update within 10 seconds, try memory reading
    this.memoryFallbackTimeout = setTimeout(() => {
      this.tryMemoryFallback();
    }, 10000);

    // Emit server changed with null
    this.emit('serverChanged', null);
  }

  /**
   * Handle Roblox process stopped
   */
  handleProcessStopped() {
    // Stop log monitoring
    logMonitor.stopMonitoring();

    // Clear memory fallback timeout
    if (this.memoryFallbackTimeout) {
      clearTimeout(this.memoryFallbackTimeout);
      this.memoryFallbackTimeout = null;
    }

    // Clear current server if set
    const previousServer = this.currentServer;
    this.currentServer = null;
    this.lastLogUpdate = null;

    // Emit server changed with null
    if (previousServer) {
      this.emit('serverChanged', null);
    }
  }

  /**
   * Handle server detected from logs
   */
  handleServerDetected(serverInfo, source) {
    // Clear memory fallback timeout
    if (this.memoryFallbackTimeout) {
      clearTimeout(this.memoryFallbackTimeout);
      this.memoryFallbackTimeout = null;
    }

    // Update last log update time
    if (source === 'log') {
      this.lastLogUpdate = Date.now();
    }

    // Check if server changed
    if (!this.currentServer || 
        this.currentServer.placeId !== serverInfo.placeId || 
        this.currentServer.jobId !== serverInfo.jobId) {
      
      logger.info('Server changed', { 
        placeId: serverInfo.placeId, 
        jobId: serverInfo.jobId,
        source 
      });
      
      this.currentServer = serverInfo;
      this.emit('serverChanged', serverInfo);
    }
  }

  /**
   * Try memory reading as fallback
   */
  async tryMemoryFallback() {
    logger.info('Log timeout reached, trying memory fallback');

    try {
      const serverInfo = await memoryReader.readServerFromMemory();

      if (serverInfo && serverInfo.placeId && serverInfo.jobId) {
        // Compare with log monitor results if available
        const logServer = logMonitor.getCurrentServer();
        
        if (logServer) {
          if (logServer.placeId === serverInfo.placeId && logServer.jobId === serverInfo.jobId) {
            // Results match, use log result
            logger.info('Memory and log results match, using log result');
            this.handleServerDetected(logServer, 'log');
          } else {
            // Results differ, prefer log, log warning
            logger.warn('Memory and log results differ', {
              log: logServer,
              memory: serverInfo
            });
            this.handleServerDetected(logServer, 'log');
          }
        } else {
          // No log data, use memory result
          logger.info('No log data, using memory result');
          this.handleServerDetected(serverInfo, 'memory');
        }
      } else {
        logger.warn('Memory reading failed to find server');
      }
    } catch (error) {
      logger.error('Memory fallback failed', { error: error.message });
    }
  }

  /**
   * Get current server information
   */
  getCurrentServer() {
    return this.currentServer;
  }

  /**
   * Check if detector is running
   */
  isActive() {
    return this.isRunning;
  }
}

// Export singleton instance
module.exports = new Detector();
</file>

<file path="src/main/detection/logMonitor.js">
const fs = require('fs');
const path = require('path');
const { EventEmitter } = require('events');
const logger = require('../logging/logger');

// Roblox log directory path
const LOG_DIR = process.env.LOCALAPPDATA 
  ? path.join(process.env.LOCALAPPDATA, 'Roblox', 'logs')
  : path.join(process.env.HOME, '.roblox', 'logs');

// Regex patterns for parsing log lines
const JOIN_PATTERN = /\[FLog::Output\]\s*!\s*Joining\s*game\s*['"`]?(\d+)['"`]?\s*place\s*['"`]?([0-9a-f-]+)['"`]?/i;
const SERVER_PATTERN = /gameplacejobid/i;

class LogMonitor extends EventEmitter {
  constructor() {
    super();
    this.isMonitoring = false;
    this.watchInterval = null;
    this.currentLogFile = null;
    this.lastPosition = 0;
    this.lastServerInfo = null;
  }

  /**
   * Start monitoring Roblox log files
   */
  startMonitoring() {
    if (this.isMonitoring) {
      logger.warn('Log monitor already running');
      return;
    }

    logger.info('Starting log monitor', { logDir: LOG_DIR });
    this.isMonitoring = true;

    // Initial check for log file
    this.checkLogFile();

    // Set up interval to check for new log entries (every 500ms)
    this.watchInterval = setInterval(() => {
      this.readNewLogs();
    }, 500);
  }

  /**
   * Stop monitoring log files
   */
  stopMonitoring() {
    if (!this.isMonitoring) {
      logger.warn('Log monitor not running');
      return;
    }

    logger.info('Stopping log monitor');
    this.isMonitoring = false;
    
    if (this.watchInterval) {
      clearInterval(this.watchInterval);
      this.watchInterval = null;
    }

    // Reset state
    this.currentLogFile = null;
    this.lastPosition = 0;
  }

  /**
   * Find and check the most recent log file
   */
  checkLogFile() {
    try {
      if (!fs.existsSync(LOG_DIR)) {
        logger.warn('Log directory does not exist', { logDir: LOG_DIR });
        return;
      }

      // Get all .log files
      const files = fs.readdirSync(LOG_DIR)
        .filter(file => file.endsWith('.log'))
        .map(file => ({
          name: file,
          path: path.join(LOG_DIR, file),
          mtime: fs.statSync(path.join(LOG_DIR, file)).mtime
        }))
        .sort((a, b) => b.mtime - a.mtime);

      if (files.length === 0) {
        logger.debug('No log files found');
        return;
      }

      // Get the most recent log file
      const mostRecent = files[0];

      // Check if log file changed
      if (this.currentLogFile !== mostRecent.path) {
        logger.info('New log file detected', { file: mostRecent.name });
        this.currentLogFile = mostRecent.path;
        this.lastPosition = 0; // Reset position for new file
      }
    } catch (error) {
      logger.error('Error checking log file', { error: error.message });
    }
  }

  /**
   * Read new log entries since last position
   */
  readNewLogs() {
    if (!this.currentLogFile) {
      this.checkLogFile();
      return;
    }

    try {
      const stats = fs.statSync(this.currentLogFile);
      const fileSize = stats.size;

      // If file was truncated (rotated), reset position
      if (fileSize < this.lastPosition) {
        logger.debug('Log file was truncated, resetting position');
        this.lastPosition = 0;
      }

      // If no new data, return
      if (fileSize <= this.lastPosition) {
        return;
      }

      // Read new data from file
      const stream = fs.createReadStream(this.currentLogFile, {
        start: this.lastPosition,
        encoding: 'utf8'
      });

      let newData = '';
      stream.on('data', (chunk) => {
        newData += chunk;
      });

      stream.on('end', () => {
        this.parseLogs(newData);
        this.lastPosition = fileSize;
      });

      stream.on('error', (error) => {
        logger.error('Error reading log file', { error: error.message });
      });
    } catch (error) {
      logger.error('Error reading new logs', { error: error.message });
    }
  }

  /**
   * Parse log lines and extract server information
   */
  parseLogs(data) {
    const lines = data.split('\n');

    for (const line of lines) {
      this.parseLine(line);
    }
  }

  /**
   * Parse a single log line and emit events
   */
  parseLine(line) {
    // Try to match the join pattern
    const joinMatch = line.match(JOIN_PATTERN);
    
    if (joinMatch) {
      const placeId = joinMatch[1];
      const jobId = joinMatch[2];
      const serverInfo = {
        placeId,
        jobId,
        timestamp: Date.now()
      };

      // Check if server changed
      if (!this.lastServerInfo || 
          this.lastServerInfo.placeId !== serverInfo.placeId || 
          this.lastServerInfo.jobId !== serverInfo.jobId) {
        
        logger.info('Server detected', { placeId, jobId });
        this.lastServerInfo = serverInfo;
        this.emit('serverDetected', serverInfo);
      }
    }
  }

  /**
   * Get current server information
   */
  getCurrentServer() {
    return this.lastServerInfo;
  }
}

module.exports = new LogMonitor();
</file>

<file path="src/main/detection/memoryReader.js">
const logger = require('../logging/logger');

// NOTE: Memory reading is complex and requires research
// This is a placeholder implementation
// For production, you would need:
// - npm install memoryjs (or similar library)
// - Research actual memory offsets for PlaceId/JobId
// - Handle process permissions and anti-cheat

// Placeholder for memory offsets (would need research)
const OFFSETS = {
  placeId: null,  // TODO: Research actual offset
  jobId: null     // TODO: Research actual offset
};

/**
 * FALLBACK: Read memory of RobloxPlayerBeta.exe to find PlaceId/JobId
 * This should only be used when log monitoring fails
 * 
 * @returns {Object|null} { placeId, jobId } or null if not found
 */
async function readServerFromMemory() {
  try {
    logger.info('Attempting memory reading as fallback');
    
    // Check if memoryjs is available
    let memoryjs;
    try {
      memoryjs = require('memoryjs');
    } catch (error) {
      logger.warn('memoryjs not installed, memory reading unavailable');
      return null;
    }

    // Find RobloxPlayerBeta.exe process
    const processList = memoryjs.getProcesses();
    const robloxProcess = processList.find(p => 
      p.szExeFile && p.szExeFile.toLowerCase() === 'robloxplayerbeta.exe'
    );

    if (!robloxProcess) {
      logger.warn('Roblox process not found for memory reading');
      return null;
    }

    logger.debug('Found Roblox process', { pid: robloxProcess.th32ProcessID });

    // Open process for reading
    const processObject = memoryjs.openProcess(robloxProcess.th32ProcessID);

    // TODO: Research actual offsets and implement reading
    // This is a simplified example - actual implementation would be more complex
    
    // Example (would need real offsets):
    // const placeIdBuffer = memoryjs.readMemory(processObject.handle, OFFSETS.placeId, memoryjs.INT);
    // const jobIdBuffer = memoryjs.readMemory(processObject.handle, OFFSETS.jobId, memoryjs.STRING);
    
    logger.warn('Memory reading not fully implemented - requires research');
    
    // Close process handle
    memoryjs.closeProcess(processObject.handle);

    return null;
  } catch (error) {
    logger.error('Memory reading failed', { error: error.message });
    return null;
  }
}

/**
 * Check if memory reading is available
 */
function isAvailable() {
  try {
    require('memoryjs');
    // Also check if offsets are configured
    return OFFSETS.placeId !== null && OFFSETS.jobId !== null;
  } catch (error) {
    return false;
  }
}

/**
 * Get current memory offsets
 */
function getOffsets() {
  return { ...OFFSETS };
}

/**
 * Set memory offsets (for configuration)
 */
function setOffsets(placeIdOffset, jobIdOffset) {
  logger.info('Setting memory offsets', { placeIdOffset, jobIdOffset });
  OFFSETS.placeId = placeIdOffset;
  OFFSETS.jobId = jobIdOffset;
}

module.exports = {
  readServerFromMemory,
  isAvailable,
  getOffsets,
  setOffsets
};
</file>

<file path="src/main/detection/processWatcher">

</file>

<file path="src/main/detection/processWatcher.js">
const { EventEmitter } = require('events');
const { exec } = require('child_process');
const { promisify } = require('util');
const logger = require('../logging/logger');

const execAsync = promisify(exec);

// Process name to watch (Windows)
const ROBLOX_PROCESS = 'RobloxPlayerBeta.exe';

class ProcessWatcher extends EventEmitter {
  constructor() {
    super();
    this.isWatching = false;
    this.checkInterval = null;
    this.wasRunning = false;
  }

  /**
   * Start watching for Roblox process
   * Checks every 2 seconds
   */
  startWatching() {
    if (this.isWatching) {
      logger.warn('Process watcher already running');
      return;
    }

    logger.info('Starting process watcher');
    this.isWatching = true;

    // Initial check
    this.checkProcess();

    // Set up interval to check every 2 seconds
    this.checkInterval = setInterval(() => {
      this.checkProcess();
    }, 2000);
  }

  /**
   * Stop watching for Roblox process
   */
  stopWatching() {
    if (!this.isWatching) {
      logger.warn('Process watcher not running');
      return;
    }

    logger.info('Stopping process watcher');
    this.isWatching = false;
    
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }

  /**
   * Check if Roblox is running and emit events on state change
   */
  async checkProcess() {
    try {
      const isRunning = await this.isRobloxRunning();

      // Emit events only when state changes
      if (isRunning && !this.wasRunning) {
        logger.info('Roblox process started');
        this.emit('processStarted');
      } else if (!isRunning && this.wasRunning) {
        logger.info('Roblox process stopped');
        this.emit('processStopped');
      }

      this.wasRunning = isRunning;
    } catch (error) {
      logger.error('Error checking Roblox process', { error: error.message });
    }
  }

  /**
   * Check if Roblox process is currently running
   */
  async isRobloxRunning() {
    try {
      const platform = process.platform;
      let command;

      if (platform === 'win32') {
        // Windows: Use tasklist
        command = `tasklist /FI "IMAGENAME eq ${ROBLOX_PROCESS}" /FI "STATUS eq running"`;
      } else if (platform === 'darwin') {
        // macOS: Use ps
        command = `ps aux | grep -i "${ROBLOX_PROCESS}" | grep -v grep`;
      } else {
        // Linux: Use pgrep
        command = `pgrep -f "${ROBLOX_PROCESS}"`;
      }

      const { stdout } = await execAsync(command);

      // Check if process name appears in output
      return stdout.toLowerCase().includes(ROBLOX_PROCESS.toLowerCase());
    } catch (error) {
      // If command fails, assume process not running
      logger.debug('Process check failed, assuming not running', { error: error.message });
      return false;
    }
  }

  /**
   * Get current running status
   */
  isRunning() {
    return this.wasRunning;
  }
}

module.exports = new ProcessWatcher();
</file>

<file path="src/main/index.js">
const { app, BrowserWindow } = require('electron');
const path = require('path');
const logger = require('./logging/logger');
const { registerHandlers, setMainWindow, setupDetectorEvents } = require('./ipc/handlers');
const detector = require('./detection/detector');
const secureStore = require('./storage/secureStore');
require('dotenv').config();

let mainWindow;

/**
 * Create main browser window
 */
function createWindow() {
  logger.info('Creating main window');

  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    show: false,
    webPreferences: {
      preload: path.join(__dirname, '../preload/preload.js'),
      nodeIntegration: false,
      contextIsolation: true,
      sandbox: true
    }
  });

  // Load renderer index.html
  mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));

  // Show window when ready
  mainWindow.once('ready-to-show', () => {
    logger.info('Window ready to show');
    mainWindow.show();
    
    // Show DevTools in development
    if (process.env.NODE_ENV !== 'production') {
      mainWindow.webContents.openDevTools();
    }
  });

  // Handle window closed
  mainWindow.on('closed', () => {
    logger.info('Window closed');
    mainWindow = null;
  });

  // Handle navigation errors
  mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription) => {
    logger.error('Failed to load page', { errorCode, errorDescription });
  });

  // Set window reference for IPC handlers
  setMainWindow(mainWindow);
}

/**
 * Validate environment variables
 */
function validateEnvironment() {
  const requiredEnvVars = [];
  
  // MongoDB is required for server
  // The client doesn't need DB_URL, but server does
  if (process.env.NODE_ENV !== 'production') {
    logger.info('Running in development mode');
  }
  
  // Warn if server URL not configured
  if (!process.env.SERVER_URL) {
    logger.warn('SERVER_URL not set, using default: http://localhost:3000');
  }
}

/**
 * Initialize application
 */
app.whenReady().then(() => {
  // Validate environment variables
  validateEnvironment();
  logger.info('App started');
  
  // Register IPC handlers
  registerHandlers();
  
  // Setup detector events forwarding
  setupDetectorEvents();
  
  // Create main window
  createWindow();
  
  // Check if user is authenticated
  if (secureStore.isAuthenticated()) {
    logger.info('User is authenticated, starting detector');
    detector.start();
  } else {
    logger.info('User not authenticated, showing login view');
  }
  
  // Handle macOS dock icon click
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

/**
 * Handle all windows closed
 */
app.on('window-all-closed', () => {
  logger.info('All windows closed');
  
  // On macOS, keep app running until explicitly quit
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

/**
 * Handle app quit
 */
app.on('before-quit', () => {
  logger.info('App quitting');
  
  // Stop detector
  if (detector.isActive()) {
    logger.info('Stopping detector');
    detector.stop();
  }
});

/**
 * Handle app will quit
 */
app.on('will-quit', (event) => {
  logger.info('App will quit');
});

/**
 * Handle uncaught exceptions
 */
process.on('uncaughtException', (error) => {
  logger.error('Uncaught exception', { error: error.message, stack: error.stack });
});

/**
 * Handle unhandled promise rejections
 */
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled promise rejection', { reason });
});
</file>

<file path="src/main/ipc/handlers.js">
const { ipcMain } = require('electron');
const robloxAuth = require('../auth/robloxAuth');
const tokenManager = require('../auth/tokenManager');
const detector = require('../detection/detector');
const secureStore = require('../storage/secureStore');
const logger = require('../logging/logger');

// Store reference to main window for sending events
let mainWindow = null;

/**
 * Set the main window reference
 */
function setMainWindow(window) {
  mainWindow = window;
  logger.info('Main window set for IPC handlers');
}

/**
 * Forward detector events to renderer
 */
function setupDetectorEvents() {
  detector.on('serverChanged', (serverInfo) => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('detection:serverChanged', serverInfo);
    }
  });
}

/**
 * Register all IPC handlers
 */
function registerHandlers() {
  logger.info('Registering IPC handlers');

  // Auth handlers
  ipcMain.handle('auth:login', handleLogin);
  ipcMain.handle('auth:logout', handleLogout);
  ipcMain.handle('auth:getStatus', handleGetStatus);

  // Detection handlers
  ipcMain.handle('detection:getServer', handleGetServer);
  ipcMain.handle('detection:start', handleStartDetection);
  ipcMain.handle('detection:stop', handleStopDetection);

  logger.info('IPC handlers registered successfully');
}

// ==================== AUTH HANDLERS ====================

/**
 * Handle login request
 */
async function handleLogin(event) {
  try {
    logger.info('Login requested');
    const userInfo = await robloxAuth.initiateLogin();
    return { success: true, user: userInfo };
  } catch (error) {
    logger.error('Login failed', { error: error.message });
    return { success: false, error: error.message };
  }
}

/**
 * Handle logout request
 */
async function handleLogout(event) {
  try {
    logger.info('Logout requested');
    const result = tokenManager.logout();
    return { success: result };
  } catch (error) {
    logger.error('Logout failed', { error: error.message });
    return { success: false, error: error.message };
  }
}

/**
 * Handle get authentication status request
 */
async function handleGetStatus(event) {
  try {
    const isAuthenticated = robloxAuth.isAuthenticated();
    const user = robloxAuth.getCurrentUser();
    
    return {
      success: true,
      authenticated: isAuthenticated,
      user
    };
  } catch (error) {
    logger.error('Failed to get auth status', { error: error.message });
    return { success: false, error: error.message };
  }
}

// ==================== DETECTION HANDLERS ====================

/**
 * Handle get current server request
 */
async function handleGetServer(event) {
  try {
    const server = detector.getCurrentServer();
    return { success: true, server };
  } catch (error) {
    logger.error('Failed to get server', { error: error.message });
    return { success: false, error: error.message };
  }
}

/**
 * Handle start detection request
 */
async function handleStartDetection(event) {
  try {
    logger.info('Start detection requested');
    detector.start();
    return { success: true };
  } catch (error) {
    logger.error('Failed to start detection', { error: error.message });
    return { success: false, error: error.message };
  }
}

/**
 * Handle stop detection request
 */
async function handleStopDetection(event) {
  try {
    logger.info('Stop detection requested');
    detector.stop();
    return { success: true };
  } catch (error) {
    logger.error('Failed to stop detection', { error: error.message });
    return { success: false, error: error.message };
  }
}

module.exports = {
  setMainWindow,
  registerHandlers,
  setupDetectorEvents
};
</file>

<file path="src/main/logging/logger.js">
const winston = require('winston');
const path = require('path');

const isDevelopment = process.env.NODE_ENV !== 'production';

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.printf(({ timestamp, level, message, ...metadata }) => {
    let msg = `${timestamp} [${level.toUpperCase()}]: ${message}`;
    if (Object.keys(metadata).length > 0) {
      msg += ` ${JSON.stringify(metadata)}`;
    }
    return msg;
  })
);

// Create logger instance
const logger = winston.createLogger({
  level: isDevelopment ? 'debug' : 'info',
  format: logFormat,
  transports: [
    // Console transport (colorized in development)
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        logFormat
      )
    }),
    // File transport - all logs
    new winston.transports.File({
      filename: path.join(__dirname, '../../../logs/app.log'),
      maxsize: 5 * 1024 * 1024, // 5MB
      maxFiles: 5
    }),
    // Error file transport - errors only
    new winston.transports.File({
      filename: path.join(__dirname, '../../../logs/error.log'),
      level: 'error',
      maxsize: 5 * 1024 * 1024, // 5MB
      maxFiles: 5
    })
  ]
});

module.exports = logger;
</file>

<file path="src/main/logging/logRotate.js">

</file>

<file path="src/main/storage/secureStore.js">
const Store = require('electron-store');
const { app } = require('electron');
const logger = require('../logging/logger');

// Initialize Store with encryption
const secureStore = new Store({
  name: 'rochat-auth',
  encryptionKey: 'rochat-secure-storage-key', // In production, use a more secure key
  defaults: {
    auth: null
  }
});

// Save authentication data
function saveAuth(authData) {
  try {
    logger.info('Saving authentication data', { username: authData.username });
    secureStore.set('auth', {
      robloxToken: authData.robloxToken,
      userId: authData.userId,
      username: authData.username,
      expiresAt: authData.expiresAt,
      refreshToken: authData.refreshToken
    });
    return true;
  } catch (error) {
    logger.error('Failed to save authentication data', { error: error.message });
    return false;
  }
}

// Get authentication data
function getAuth() {
  try {
    const auth = secureStore.get('auth');
    
    if (!auth) {
      return null;
    }
    
    // Check if token is expired
    if (Date.now() >= auth.expiresAt) {
      logger.warn('Authentication token expired', { expiresAt: auth.expiresAt });
      return null;
    }
    
    return auth;
  } catch (error) {
    logger.error('Failed to get authentication data', { error: error.message });
    return null;
  }
}

// Clear all authentication data
function clearAuth() {
  try {
    logger.info('Clearing authentication data');
    secureStore.delete('auth');
    return true;
  } catch (error) {
    logger.error('Failed to clear authentication data', { error: error.message });
    return false;
  }
}

// Check if user is authenticated
function isAuthenticated() {
  const auth = getAuth();
  const isAuth = auth !== null;
  logger.debug('Authentication status check', { isAuthenticated: isAuth });
  return isAuth;
}

module.exports = {
  saveAuth,
  getAuth,
  clearAuth,
  isAuthenticated
};
</file>

<file path="src/preload/preload.js">
const { contextBridge, ipcRenderer } = require('electron');

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld('electronAPI', {
  // Auth methods
  auth: {
    login: () => ipcRenderer.invoke('auth:login'),
    logout: () => ipcRenderer.invoke('auth:logout'),
    getStatus: () => ipcRenderer.invoke('auth:getStatus')
  },

  // Detection methods
  detection: {
    getServer: () => ipcRenderer.invoke('detection:getServer'),
    start: () => ipcRenderer.invoke('detection:start'),
    stop: () => ipcRenderer.invoke('detection:stop')
  },

  // Event listeners
  onServerChanged: (callback) => {
    const listener = (event, serverInfo) => callback(serverInfo);
    ipcRenderer.on('detection:serverChanged', listener);
    
    // Return unsubscribe function
    return () => {
      ipcRenderer.removeListener('detection:serverChanged', listener);
    };
  }
});
</file>

<file path="src/renderer/css/main.css">
/* Main stylesheet for RoChat */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  overflow: hidden;
}

#app {
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Views */
.view {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.view.hidden {
  display: none;
}

/* Login View */
.login-container {
  text-align: center;
  padding: 40px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  max-width: 400px;
  width: 100%;
}

.login-container h1 {
  font-size: 32px;
  margin-bottom: 8px;
}

.subtitle {
  color: #666;
  margin-bottom: 24px;
}

.status {
  margin-top: 16px;
  font-size: 14px;
}

.status.success {
  color: #4caf50;
}

.status.error {
  color: #f44336;
}

/* Chat View */
.chat-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.chat-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
}

.server-info {
  display: flex;
  align-items: center;
  gap: 8px;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: #9e9e9e;
}

.status-dot.online {
  background-color: #4caf50;
}

.status-dot.offline {
  background-color: #f44336;
}

.server-text {
  font-weight: 500;
}

.user-info {
  flex: 1;
  text-align: center;
  font-weight: 500;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.chat-message {
  max-width: 70%;
  padding: 12px;
  border-radius: 12px;
  word-wrap: break-word;
}

.chat-message.local {
  align-self: flex-end;
  background-color: #1976d2;
  color: white;
}

.chat-message.remote {
  align-self: flex-start;
  background-color: #f5f5f5;
  color: #333;
}

.chat-message.error {
  align-self: center;
  background-color: #ffebee;
  color: #c62828;
  max-width: 90%;
}

.message-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
  font-size: 12px;
  opacity: 0.8;
}

.username {
  font-weight: 600;
}

.timestamp {
  font-size: 11px;
  opacity: 0.7;
}

.message-content {
  line-height: 1.4;
}

.chat-input {
  display: flex;
  gap: 8px;
  padding: 12px 16px;
  border-top: 1px solid #e0e0e0;
}

.chat-input input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 14px;
}

.chat-input input:focus {
  outline: none;
  border-color: #1976d2;
}

/* Settings View */
.settings-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
}

.settings-header h2 {
  font-size: 20px;
}

.settings-content {
  flex: 1;
  padding: 24px;
  overflow-y: auto;
}

.setting-group {
  margin-bottom: 24px;
}

.setting-group h3 {
  font-size: 16px;
  margin-bottom: 12px;
}

.setting-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 0;
  border-bottom: 1px solid #f0f0f0;
}

.setting-item:last-child {
  border-bottom: none;
}

.setting-item label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}

.setting-item select {
  padding: 6px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  font-size: 14px;
}

/* Buttons */
.btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-primary {
  background-color: #1976d2;
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background-color: #1565c0;
}

.btn-danger {
  background-color: #f44336;
  color: white;
}

.btn-danger:hover:not(:disabled) {
  background-color: #d32f2f;
}

.btn-icon {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.btn-icon:hover {
  background-color: #f0f0f0;
}

/* Scrollbar */
.chat-messages::-webkit-scrollbar {
  width: 8px;
}

.chat-messages::-webkit-scrollbar-track {
  background: transparent;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 4px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
  background: #999;
}
</file>

<file path="src/renderer/css/themes.css">
/* Theme styles for RoChat */

/* Light Theme (default) */
body.theme-light {
  background-color: #ffffff;
  color: #333333;
}

body.theme-light .login-container {
  background-color: #ffffff;
  border: 1px solid #e0e0e0;
}

body.theme-light .subtitle {
  color: #666666;
}

body.theme-light .chat-header {
  background-color: #ffffff;
  border-bottom: 1px solid #e0e0e0;
}

body.theme-light .settings-header {
  background-color: #ffffff;
  border-bottom: 1px solid #e0e0e0;
}

body.theme-light .settings-content {
  background-color: #fafafa;
}

body.theme-light .setting-item {
  border-bottom: 1px solid #e8e8e8;
}

body.theme-light .setting-item select {
  background-color: #ffffff;
  border-color: #cccccc;
}

body.theme-light .chat-input input {
  background-color: #ffffff;
  border-color: #dddddd;
  color: #333333;
}

body.theme-light .chat-input input::placeholder {
  color: #999999;
}

body.theme-light .chat-input input:focus {
  border-color: #1976d2;
}

/* Dark Theme */
body.theme-dark {
  background-color: #1e1e1e;
  color: #e0e0e0;
}

body.theme-dark .login-container {
  background-color: #2d2d2d;
  border: 1px solid #3d3d3d;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

body.theme-dark .subtitle {
  color: #a0a0a0;
}

body.theme-dark .status.success {
  color: #66bb6a;
}

body.theme-dark .status.error {
  color: #ef5350;
}

body.theme-dark .chat-header {
  background-color: #2d2d2d;
  border-bottom: 1px solid #3d3d3d;
}

body.theme-dark .server-text {
  color: #e0e0e0;
}

body.theme-dark .user-info {
  color: #b0b0b0;
}

body.theme-dark .chat-message.remote {
  background-color: #3d3d3d;
  color: #e0e0e0;
}

body.theme-dark .chat-message.error {
  background-color: #4a2c2c;
  color: #ef9a9a;
}

body.theme-dark .message-header {
  color: #b0b0b0;
}

body.theme-dark .chat-input {
  background-color: #2d2d2d;
  border-top: 1px solid #3d3d3d;
}

body.theme-dark .chat-input input {
  background-color: #1e1e1e;
  border-color: #3d3d3d;
  color: #e0e0e0;
}

body.theme-dark .chat-input input::placeholder {
  color: #666666;
}

body.theme-dark .chat-input input:focus {
  border-color: #42a5f5;
  outline: none;
}

body.theme-dark .settings-header {
  background-color: #2d2d2d;
  border-bottom: 1px solid #3d3d3d;
}

body.theme-dark .settings-header h2 {
  color: #e0e0e0;
}

body.theme-dark .settings-content {
  background-color: #1e1e1e;
}

body.theme-dark .setting-group h3 {
  color: #e0e0e0;
}

body.theme-dark .setting-item {
  border-bottom: 1px solid #3d3d3d;
}

body.theme-dark .setting-item label {
  color: #b0b0b0;
}

body.theme-dark .setting-item select {
  background-color: #2d2d2d;
  border-color: #4d4d4d;
  color: #e0e0e0;
}

body.theme-dark .btn-primary {
  background-color: #42a5f5;
}

body.theme-dark .btn-primary:hover:not(:disabled) {
  background-color: #1e88e5;
}

body.theme-dark .btn-danger {
  background-color: #ef5350;
}

body.theme-dark .btn-danger:hover:not(:disabled) {
  background-color: #c62828;
}

body.theme-dark .btn-icon:hover {
  background-color: #3d3d3d;
}

/* Auto Theme (inherits from system, defaults to light) */
body.theme-auto {
  background-color: #ffffff;
  color: #333333;
}

body.theme-auto .login-container {
  background-color: #ffffff;
  border: 1px solid #e0e0e0;
}

body.theme-auto .chat-header {
  background-color: #ffffff;
  border-bottom: 1px solid #e0e0e0;
}

body.theme-auto .settings-header {
  background-color: #ffffff;
  border-bottom: 1px solid #e0e0e0;
}

body.theme-auto .settings-content {
  background-color: #fafafa;
}

body.theme-auto .chat-input {
  background-color: #ffffff;
  border-top: 1px solid #e0e0e0;
}

body.theme-auto .chat-input input {
  background-color: #ffffff;
  border-color: #dddddd;
  color: #333333;
}

/* Dark mode override for auto theme */
@media (prefers-color-scheme: dark) {
  body.theme-auto {
    background-color: #1e1e1e;
    color: #e0e0e0;
  }

  body.theme-auto .login-container {
    background-color: #2d2d2d;
    border: 1px solid #3d3d3d;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  body.theme-auto .subtitle {
    color: #a0a0a0;
  }

  body.theme-auto .chat-header {
    background-color: #2d2d2d;
    border-bottom: 1px solid #3d3d3d;
  }

  body.theme-auto .server-text {
    color: #e0e0e0;
  }

  body.theme-auto .user-info {
    color: #b0b0b0;
  }

  body.theme-auto .chat-message.remote {
    background-color: #3d3d3d;
    color: #e0e0e0;
  }

  body.theme-auto .chat-message.error {
    background-color: #4a2c2c;
    color: #ef9a9a;
  }

  body.theme-auto .message-header {
    color: #b0b0b0;
  }

  body.theme-auto .chat-input {
    background-color: #2d2d2d;
    border-top: 1px solid #3d3d3d;
  }

  body.theme-auto .chat-input input {
    background-color: #1e1e1e;
    border-color: #3d3d3d;
    color: #e0e0e0;
  }

  body.theme-auto .chat-input input::placeholder {
    color: #666666;
  }

  body.theme-auto .chat-input input:focus {
    border-color: #42a5f5;
  }

  body.theme-auto .settings-header {
    background-color: #2d2d2d;
    border-bottom: 1px solid #3d3d3d;
  }

  body.theme-auto .settings-header h2 {
    color: #e0e0e0;
  }

  body.theme-auto .settings-content {
    background-color: #1e1e1e;
  }

  body.theme-auto .setting-group h3 {
    color: #e0e0e0;
  }

  body.theme-auto .setting-item {
    border-bottom: 1px solid #3d3d3d;
  }

  body.theme-auto .setting-item label {
    color: #b0b0b0;
  }

  body.theme-auto .setting-item select {
    background-color: #2d2d2d;
    border-color: #4d4d4d;
    color: #e0e0e0;
  }

  body.theme-auto .btn-primary {
    background-color: #42a5f5;
  }

  body.theme-auto .btn-primary:hover:not(:disabled) {
    background-color: #1e88e5;
  }

  body.theme-auto .btn-danger {
    background-color: #ef5350;
  }

  body.theme-auto .btn-danger:hover:not(:disabled) {
    background-color: #c62828;
  }

  body.theme-auto .btn-icon:hover {
    background-color: #3d3d3d;
  }
}
</file>

<file path="src/renderer/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';">
  <title>RoChat</title>
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/themes.css">
</head>
<body>
  <div id="app">
    <!-- Login View -->
    <div id="login-view" class="view hidden">
      <div class="login-container">
        <h1>RoChat</h1>
        <p class="subtitle">Roblox Chat Relay Application</p>
        <button id="login-btn" class="btn btn-primary">Login with Roblox</button>
        <p class="status" id="login-status"></p>
      </div>
    </div>

    <!-- Chat View -->
    <div id="chat-view" class="view hidden">
      <div class="chat-container">
        <div class="chat-header">
          <div class="server-info" id="server-info">
            <span class="status-dot"></span>
            <span class="server-text">Not connected</span>
          </div>
          <div class="user-info" id="user-info"></div>
          <button id="settings-btn" class="btn-icon">⚙️</button>
        </div>
        <div class="chat-messages" id="chat-messages">
          <!-- Messages will be inserted here -->
        </div>
        <div class="chat-input">
          <input type="text" id="message-input" placeholder="Type a message...">
          <button id="send-btn" class="btn btn-primary">Send</button>
        </div>
      </div>
    </div>

    <!-- Settings View -->
    <div id="settings-view" class="view hidden">
      <div class="settings-container">
        <div class="settings-header">
          <h2>Settings</h2>
          <button id="close-settings-btn" class="btn-icon">✕</button>
        </div>
        <div class="settings-content">
          <div class="setting-group">
            <h3>Appearance</h3>
            <div class="setting-item">
              <label>Theme</label>
              <select id="theme-select">
                <option value="light">Light</option>
                <option value="dark">Dark</option>
                <option value="auto">Auto</option>
              </select>
            </div>
          </div>
          <div class="setting-group">
            <h3>Behavior</h3>
            <div class="setting-item">
              <label>
                <input type="checkbox" id="auto-start-detection">
                Auto-start detection
              </label>
            </div>
          </div>
          <div class="setting-group">
            <h3>Account</h3>
            <button id="logout-btn" class="btn btn-danger">Logout</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="js/app.js"></script>
  <script src="js/chat.js"></script>
  <script src="js/settings.js"></script>
</body>
</html>
</file>

<file path="src/renderer/js/app.js">
// Main app logic for RoChat renderer

class RoChatApp {
  constructor() {
    this.currentUser = null;
    this.currentView = null;
    this.isInitialized = false;
  }

  /**
   * Initialize the application
   */
  async init() {
    if (this.isInitialized) return;

    try {
      // Check authentication status
      const status = await window.electronAPI.auth.getStatus();
      
      if (status.success && status.authenticated) {
        this.currentUser = status.user;
        this.showView('chat');
        await this.startDetection();
      } else {
        this.showView('login');
      }

      // Setup event listeners
      this.setupEventListeners();

      this.isInitialized = true;
      console.log('RoChat initialized');
    } catch (error) {
      console.error('Failed to initialize:', error);
      this.showView('login');
    }
  }

  /**
   * Setup global event listeners
   */
  setupEventListeners() {
    // Login button
    document.getElementById('login-btn').addEventListener('click', () => this.handleLogin());
    
    // Settings button
    document.getElementById('settings-btn').addEventListener('click', () => this.showView('settings'));
    
    // Close settings button
    document.getElementById('close-settings-btn').addEventListener('click', () => this.showView('chat'));
    
    // Listen for server changes
    window.electronAPI.detection.onServerChanged((serverInfo) => {
      this.handleServerChanged(serverInfo);
    });
  }

  /**
   * Show a specific view
   */
  showView(viewName) {
    // Hide all views
    document.querySelectorAll('.view').forEach(view => {
      view.classList.add('hidden');
    });

    // Show requested view
    const view = document.getElementById(`${viewName}-view`);
    if (view) {
      view.classList.remove('hidden');
    }

    this.currentView = viewName;
    console.log('View changed to:', viewName);

    // Update user info if showing chat
    if (viewName === 'chat' && this.currentUser) {
      document.getElementById('user-info').textContent = this.currentUser.username;
    }
  }

  /**
   * Handle login
   */
  async handleLogin() {
    const loginBtn = document.getElementById('login-btn');
    const statusEl = document.getElementById('login-status');

    loginBtn.disabled = true;
    loginBtn.textContent = 'Logging in...';
    statusEl.textContent = '';

    try {
      const result = await window.electronAPI.auth.login();

      if (result.success) {
        this.currentUser = result.user;
        console.log('Login successful:', this.currentUser);
        statusEl.textContent = 'Login successful!';
        statusEl.className = 'status success';
        
        setTimeout(() => {
          this.showView('chat');
          this.startDetection();
        }, 500);
      } else {
        console.error('Login failed:', result.error);
        statusEl.textContent = result.error || 'Login failed';
        statusEl.className = 'status error';
        loginBtn.disabled = false;
        loginBtn.textContent = 'Login with Roblox';
      }
    } catch (error) {
      console.error('Login error:', error);
      statusEl.textContent = 'An error occurred';
      statusEl.className = 'status error';
      loginBtn.disabled = false;
      loginBtn.textContent = 'Login with Roblox';
    }
  }

  /**
   * Handle logout
   */
  async handleLogout() {
    if (!confirm('Are you sure you want to logout?')) return;

    try {
      const result = await window.electronAPI.auth.logout();
      
      if (result.success) {
        this.currentUser = null;
        this.showView('login');
      }
    } catch (error) {
      console.error('Logout error:', error);
      alert('Failed to logout');
    }
  }

  /**
   * Start detection
   */
  async startDetection() {
    try {
      const result = await window.electronAPI.detection.start();
      console.log('Detection started:', result);
    } catch (error) {
      console.error('Failed to start detection:', error);
    }
  }

  /**
   * Handle server changed event
   */
  handleServerChanged(serverInfo) {
    const serverInfoEl = document.getElementById('server-info');
    const statusDot = serverInfoEl.querySelector('.status-dot');
    const serverText = serverInfoEl.querySelector('.server-text');

    if (serverInfo && serverInfo.placeId && serverInfo.jobId) {
      statusDot.className = 'status-dot online';
      serverText.textContent = `Connected (Place: ${serverInfo.placeId})`;
      console.log('Server changed:', serverInfo);
    } else {
      statusDot.className = 'status-dot offline';
      serverText.textContent = 'Not connected';
      console.log('Disconnected from server');
    }
  }
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.app = new RoChatApp();
  window.app.init();
});
</file>

<file path="src/renderer/js/chat.js">
// Chat UI logic for RoChat

class ChatManager {
  constructor() {
    this.messages = [];
    this.messageInput = null;
    this.sendButton = null;
    this.messagesContainer = null;
    this.isInitialized = false;
  }

  /**
   * Initialize chat manager
   */
  init() {
    if (this.isInitialized) return;

    // Get DOM elements
    this.messageInput = document.getElementById('message-input');
    this.sendButton = document.getElementById('send-btn');
    this.messagesContainer = document.getElementById('chat-messages');

    // Setup event listeners
    this.setupEventListeners();

    this.isInitialized = true;
    console.log('Chat manager initialized');
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    // Send button click
    this.sendButton.addEventListener('click', () => this.sendMessage());

    // Enter key to send
    this.messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.sendMessage();
      }
    });
  }

  /**
   * Send a message
   */
  async sendMessage() {
    const message = this.messageInput.value.trim();
    
    if (!message) return;

    // Add message to UI immediately (optimistic update)
    this.addMessage({
      userId: window.app.currentUser?.userId,
      username: window.app.currentUser?.username || 'You',
      message: message,
      timestamp: Date.now(),
      isLocal: true
    });

    // Clear input
    this.messageInput.value = '';

    // TODO: Send message to backend server
    // This will be implemented when backend is ready
    try {
      // await window.electronAPI.chat.send(message);
      console.log('Message sent:', message);
    } catch (error) {
      console.error('Failed to send message:', error);
      this.showMessageError(message);
    }
  }

  /**
   * Add a message to the chat
   */
  addMessage(messageData) {
    const message = {
      userId: messageData.userId,
      username: messageData.username,
      message: messageData.message,
      timestamp: messageData.timestamp || Date.now(),
      isLocal: messageData.isLocal || false
    };

    this.messages.push(message);
    this.renderMessage(message);
    this.scrollToBottom();
  }

  /**
   * Render a single message
   */
  renderMessage(message) {
    const messageEl = document.createElement('div');
    messageEl.className = `chat-message ${message.isLocal ? 'local' : 'remote'}`;

    const timestamp = new Date(message.timestamp).toLocaleTimeString();

    messageEl.innerHTML = `
      <div class="message-header">
        <span class="username">${this.escapeHtml(message.username)}</span>
        <span class="timestamp">${timestamp}</span>
      </div>
      <div class="message-content">${this.escapeHtml(message.message)}</div>
    `;

    this.messagesContainer.appendChild(messageEl);
  }

  /**
   * Show message error
   */
  showMessageError(originalMessage) {
    const messageEl = document.createElement('div');
    messageEl.className = 'chat-message error';

    messageEl.innerHTML = `
      <div class="message-header">
        <span class="username">Error</span>
      </div>
      <div class="message-content">Failed to send: ${this.escapeHtml(originalMessage)}</div>
    `;

    this.messagesContainer.appendChild(messageEl);
    this.scrollToBottom();
  }

  /**
   * Clear all messages
   */
  clearMessages() {
    this.messages = [];
    this.messagesContainer.innerHTML = '';
  }

  /**
   * Scroll chat to bottom
   */
  scrollToBottom() {
    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
  }

  /**
   * Escape HTML to prevent XSS
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Initialize chat manager when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.chatManager = new ChatManager();
  
  // Wait for app to initialize
  setTimeout(() => {
    window.chatManager.init();
  }, 100);
});
</file>

<file path="src/renderer/js/settings.js">
// Settings UI logic for RoChat

class SettingsManager {
  constructor() {
    this.settings = {
      theme: 'auto',
      autoStartDetection: false
    };
    this.isInitialized = false;
  }

  /**
   * Initialize settings manager
   */
  init() {
    if (this.isInitialized) return;

    // Load settings from localStorage
    this.loadSettings();

    // Apply settings
    this.applySettings();

    // Setup event listeners
    this.setupEventListeners();

    this.isInitialized = true;
    console.log('Settings manager initialized');
  }

  /**
   * Load settings from localStorage
   */
  loadSettings() {
    try {
      const saved = localStorage.getItem('rochat-settings');
      if (saved) {
        this.settings = { ...this.settings, ...JSON.parse(saved) };
        console.log('Settings loaded:', this.settings);
      }
    } catch (error) {
      console.error('Failed to load settings:', error);
    }
  }

  /**
   * Save settings to localStorage
   */
  saveSettings() {
    try {
      localStorage.setItem('rochat-settings', JSON.stringify(this.settings));
      console.log('Settings saved:', this.settings);
    } catch (error) {
      console.error('Failed to save settings:', error);
    }
  }

  /**
   * Apply settings to the application
   */
  applySettings() {
    // Apply theme
    this.applyTheme(this.settings.theme);

    // Update UI elements
    document.getElementById('theme-select').value = this.settings.theme;
    document.getElementById('auto-start-detection').checked = this.settings.autoStartDetection;
  }

  /**
   * Apply theme to the application
   */
  applyTheme(theme) {
    const body = document.body;
    body.classList.remove('theme-light', 'theme-dark', 'theme-auto');

    if (theme === 'auto') {
      // Check system preference
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        body.classList.add('theme-dark');
      } else {
        body.classList.add('theme-light');
      }
    } else {
      body.classList.add(`theme-${theme}`);
    }

    // Listen for system theme changes if in auto mode
    if (theme === 'auto' && window.matchMedia) {
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        body.classList.remove('theme-light', 'theme-dark');
        body.classList.add(e.matches ? 'theme-dark' : 'theme-light');
      });
    }
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    // Theme select
    document.getElementById('theme-select').addEventListener('change', (e) => {
      this.settings.theme = e.target.value;
      this.applyTheme(this.settings.theme);
      this.saveSettings();
    });

    // Auto-start detection checkbox
    document.getElementById('auto-start-detection').addEventListener('change', (e) => {
      this.settings.autoStartDetection = e.target.checked;
      this.saveSettings();
    });

    // Logout button
    document.getElementById('logout-btn').addEventListener('click', () => {
      this.handleLogout();
    });
  }

  /**
   * Handle logout
   */
  async handleLogout() {
    if (!confirm('Are you sure you want to logout?')) return;

    try {
      if (window.app) {
        await window.app.handleLogout();
      }
    } catch (error) {
      console.error('Logout error:', error);
      alert('Failed to logout');
    }
  }

  /**
   * Get a setting value
   */
  getSetting(key) {
    return this.settings[key];
  }

  /**
   * Set a setting value
   */
  setSetting(key, value) {
    this.settings[key] = value;
    this.saveSettings();
    this.applySettings();
  }
}

// Initialize settings manager when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.settingsManager = new SettingsManager();
  
  // Wait for app to initialize
  setTimeout(() => {
    window.settingsManager.init();
  }, 100);
});
</file>

<file path="src/renderer/views/chat.html">

</file>

<file path="src/renderer/views/login.html">

</file>

<file path="src/renderer/views/settings.html">

</file>

<file path="src/shared/constants.js">
/**
 * Application constants
 */

// Roblox Paths
const ROBLOX_PATHS = {
  LOCAL_APP_DATA: process.env.LOCALAPPDATA || '',
  ROBLOX_LOGS: '', // Will be set dynamically
  ROBLOX_PLAYER: 'RobloxPlayerBeta.exe',
  ROBLOX_STUDIO: 'RobloxStudioBeta.exe'
};

// Roblox Log Patterns
const LOG_PATTERNS = {
  GAME_ID: /GameId=(\d+)/i,
  JOB_ID: /jobId=([a-f0-9-]{36})/i,
  PLACE_ID: /PlaceId=(\d+)/i
};

// Server Detection
const DETECTION = {
  PROCESS_NAME: 'RobloxPlayerBeta.exe',
  LOG_CHECK_INTERVAL: 1000, // 1 second
  MEMORY_FALLBACK_TIMEOUT: 10000, // 10 seconds
  LOG_PATTERN: /init:.*jobId=([a-f0-9-]{36})/i
};

// API Endpoints
const API = {
  ROBLOX: {
    BASE_URL: 'https://www.roblox.com',
    USERS: 'https://users.roblox.com',
    AUTH: 'https://auth.roblox.com',
    GAMES: 'https://games.roblox.com',
    CHAT: 'https://chat.roblox.com/v2'
  },
  SERVER: process.env.SERVER_URL || 'http://localhost:3000'
};

// Storage Keys
const STORAGE = {
  AUTH: 'auth',
  TOKEN: 'token',
  SETTINGS: 'settings',
  USER_ID: 'userId',
  USERNAME: 'username'
};

// IPC Channels
const IPC = {
  AUTH: {
    LOGIN: 'auth:login',
    LOGOUT: 'auth:logout',
    GET_STATUS: 'auth:getStatus'
  },
  DETECTION: {
    GET_SERVER: 'detection:getServer',
    START: 'detection:start',
    STOP: 'detection:stop',
    SERVER_CHANGED: 'detection:serverChanged'
  }
};

// Events
const EVENTS = {
  // Detection Events
  PROCESS_STARTED: 'processStarted',
  PROCESS_STOPPED: 'processStopped',
  SERVER_CHANGED: 'serverChanged',
  LOG_UPDATED: 'logUpdated',
  
  // Auth Events
  LOGIN_SUCCESS: 'loginSuccess',
  LOGIN_FAILURE: 'loginFailure',
  LOGOUT: 'logout',
  
  // Chat Events
  MESSAGE_RECEIVED: 'messageReceived',
  MESSAGE_SENT: 'messageSent'
};

// Socket.io Events
const SOCKET = {
  CONNECTION: 'connection',
  DISCONNECT: 'disconnect',
  JOIN_ROOM: 'join-room',
  LEAVE_ROOM: 'leave-room',
  MESSAGE: 'message'
};

// Timeouts
const TIMEOUTS = {
  API_REQUEST: 30000, // 30 seconds
  DETECTION_START: 5000, // 5 seconds
  LOG_PARSE: 2000 // 2 seconds
};

// Limits
const LIMITS = {
  MAX_MESSAGE_LENGTH: 200,
  MAX_CHAT_HISTORY: 100,
  MAX_RETRY_ATTEMPTS: 3
};

// Error Codes
const ERROR_CODES = {
  AUTH_FAILED: 'AUTH_FAILED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  SERVER_NOT_FOUND: 'SERVER_NOT_FOUND',
  PROCESS_NOT_FOUND: 'PROCESS_NOT_FOUND',
  NETWORK_ERROR: 'NETWORK_ERROR',
  TIMEOUT: 'TIMEOUT'
};

module.exports = {
  ROBLOX_PATHS,
  LOG_PATTERNS,
  DETECTION,
  API,
  STORAGE,
  IPC,
  EVENTS,
  SOCKET,
  TIMEOUTS,
  LIMITS,
  ERROR_CODES
};
</file>

<file path="src/shared/utils.js">
/**
 * Utility functions
 */

const path = require('path');
const os = require('os');

/**
 * Format a timestamp to a readable string
 */
function formatTimestamp(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleString();
}

/**
 * Format a timestamp to time only (HH:MM:SS)
 */
function formatTime(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString();
}

/**
 * Sleep/delay for a specified number of milliseconds
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Debounce a function
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle a function
 */
function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * Deep clone an object
 */
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Check if a value is empty (null, undefined, empty string, empty array, empty object)
 */
function isEmpty(value) {
  if (value == null) return true;
  if (typeof value === 'string' || Array.isArray(value)) return value.length === 0;
  if (typeof value === 'object') return Object.keys(value).length === 0;
  return false;
}

/**
 * Sanitize a string to prevent XSS
 */
function sanitizeHtml(str) {
  const map = {
    '&': '&',
    '<': '<',
    '>': '>',
    '"': '"',
    "'": '&#039;'
  };
  return str.replace(/[&<>"']/g, m => map[m]);
}

/**
 * Truncate a string to a maximum length
 */
function truncate(str, maxLength = 50, suffix = '...') {
  if (str.length <= maxLength) return str;
  return str.substring(0, maxLength - suffix.length) + suffix;
}

/**
 * Generate a random ID
 */
function generateId() {
  return Math.random().toString(36).substring(2) + Date.now().toString(36);
}

/**
 * Retry a function with exponential backoff
 */
async function retry(fn, maxRetries = 3, delay = 1000) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i < maxRetries - 1) {
        await sleep(delay * Math.pow(2, i));
      }
    }
  }
  
  throw lastError;
}

/**
 * Get Roblox log directory path
 */
function getRobloxLogsPath() {
  const platform = os.platform();
  
  if (platform === 'win32') {
    return path.join(
      process.env.LOCALAPPDATA,
      'Roblox',
      'Logs'
    );
  } else if (platform === 'darwin') {
    return path.join(
      os.homedir(),
      'Library',
      'Logs',
      'Roblox'
    );
  } else {
    return path.join(
      os.homedir(),
      '.local',
      'share',
      'Roblox',
      'Logs'
    );
  }
}

/**
 * Check if Roblox is installed
 */
function isRobloxInstalled() {
  const logsPath = getRobloxLogsPath();
  const fs = require('fs');
  
  try {
    return fs.existsSync(logsPath);
  } catch (error) {
    return false;
  }
}

/**
 * Get the latest log file from Roblox logs directory
 */
function getLatestLogFile() {
  const fs = require('fs');
  const logsPath = getRobloxLogsPath();
  
  try {
    const files = fs.readdirSync(logsPath);
    const logFiles = files.filter(f => f.endsWith('.log'));
    
    if (logFiles.length === 0) return null;
    
    // Sort by modification time, get latest
    logFiles.sort((a, b) => {
      const statA = fs.statSync(path.join(logsPath, a));
      const statB = fs.statSync(path.join(logsPath, b));
      return statB.mtime - statA.mtime;
    });
    
    return path.join(logsPath, logFiles[0]);
  } catch (error) {
    return null;
  }
}

/**
 * Parse JobId from string
 */
function parseJobId(str) {
  const jobIdRegex = /jobId=([a-f0-9-]{36})/i;
  const match = str.match(jobIdRegex);
  return match ? match[1] : null;
}

/**
 * Parse PlaceId from string
 */
function parsePlaceId(str) {
  const placeIdRegex = /PlaceId=(\d+)/i;
  const match = str.match(placeIdRegex);
  return match ? match[1] : null;
}

/**
 * Validate JobId format
 */
function isValidJobId(jobId) {
  return /^[a-f0-9-]{36}$/i.test(jobId);
}

/**
 * Validate PlaceId format
 */
function isValidPlaceId(placeId) {
  return /^\d+$/.test(placeId);
}

module.exports = {
  formatTimestamp,
  formatTime,
  sleep,
  debounce,
  throttle,
  deepClone,
  isEmpty,
  sanitizeHtml,
  truncate,
  generateId,
  retry,
  getRobloxLogsPath,
  isRobloxInstalled,
  getLatestLogFile,
  parseJobId,
  parsePlaceId,
  isValidJobId,
  isValidPlaceId
};
</file>

</files>
